<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shucunbin&#39;s blog</title>
  
  
  <link href="https://shucunbin.github.io/atom.xml" rel="self"/>
  
  <link href="https://shucunbin.github.io/"/>
  <updated>2022-01-29T06:13:13.036Z</updated>
  <id>https://shucunbin.github.io/</id>
  
  <author>
    <name>shucunbin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty 前置知识点之事件循环机制</title>
    <link href="https://shucunbin.github.io/2020/11/12/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://shucunbin.github.io/2020/11/12/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-12T02:23:10.000Z</published>
    <updated>2022-01-29T06:13:13.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/04%20%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%B1%82%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%20EventLoop%20%E6%98%AF%20Netty%20%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%9F.md">原文链接</a></p><h1><span id="基本概念">基本概念</span></h1><p>事件循环（EventLoop）这个概念其实并不是 Netty 独有的，它是一种事件等待和处理的程序模型，可以解决多线程资源消耗高的问题。例如 Node.js 就采用了 EventLoop 的运行机制，不仅占用资源低，而且能够支撑了大规模的流量访问。<br>下图展示了 EventLoop 通用的运行模式。每当事件发生时，应用程序都会将产生的事件放入事件队列当中，然后 EventLoop 会轮询从队列中取出事件执行或者将事件分给相应的事件监听者执行。事件执行的方式通常分为立即执行、延后执行、定期执行几种。<br><img src="https://thumbimg.dealmoon.com/dealmoon/3a2/688/621/7927f790413d80d513ade32.png"></p><h1><span id="netty-如何实现-eventloop">Netty 如何实现 EventLoop</span></h1><p>在 Netty 中 EventLoop 可以理解为 Reactor 线程模型的事件处理引擎，每个 EventLoop 线程都维护一个 Selector 选择器和任务队列 taskQueue。它主要负责处理 IO 事件、普通任务和定时任务。<br>Netty 中推荐使用 NioEventLoop 作为实现类，其实现核心逻辑在 NioEventLoop 的 run() 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">// 1. 轮询 IO 事件</span></span><br><span class="line">        slelect(wokenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 2. 处理 IO 事件</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line">        <span class="comment">// 3. 处理其它非 IO 事件</span></span><br><span class="line">        runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码的结构比较清晰，NioEventLoop 每次循环的处理流程都包含事件轮询 select、事件处理 processSelectedKeys、任务处理 runAllTasks 几个步骤，是典型的 Reactor 线程模型的运行机制。而且 Netty 提供类一个 ioRatio，可以调整 IO 事件处理和任务处理的时间比例。</p><h2><span id="io-事件处理">IO 事件处理</span></h2><p><img src="https://thumbimg.dealmoon.com/dealmoon/5c5/d8e/63b/a8481886b17aaf1d4e767f4.png"><br>EventLoop 事件处理机制最核心的是采用<strong>无锁串形化的设计思路</strong>：</p><ul><li>BossEventLoopGroup 和 WorkerEventLoopGroup 包含一个或者多个 NioEventLoop。BossEventLoopGroup 负责监听客户端的 Accept 事件，当事件触发时，将事件注册至 WorkerEventLoopGroup 中的一个 NioEventLoop 上。每新建一个 Channel， 只选择一个 NioEventLoop 与其绑定。所以说 Channel 生命周期的所有事件处理都是线程独立的，不同的 NioEventLoop 线程之间不会发生任何交集。</li><li>NioEventLoop 完成数据读取后，会调用绑定的 ChannelPipeline 进行事件传播，ChannelPipeline 也是线程安全的，数据会被传递到 ChannelPipeline 的第一个 ChannelHandler 中。数据处理完成后，将加工完成的数据再传递给下一个 ChannelHandler，整个过程是串行化执行，不会发生线程上下文切换的问题。</li></ul><p>NioEventLoop 无锁串形化的设计不仅使系统吞吐量达到最大化，而且降低了用户开发业务逻辑的难度，不需要花太多精力关心线程安全问题。虽然单线程执行避免了线程切换，但是它的缺陷就是不能执行时间过长的 I/O 操作，一旦某个 I/O 事件发生阻塞，那么后续的所有 I/O 事件都无法执行，甚至造成事件积压。<strong>在使用 Netty 进行程序开发时，我们一定要对 ChannelHandler 的实现逻辑有充分的风险意识</strong>。<br>Netty 解决  JDK Epoll 空轮询的方式：</p><ol><li>每次执行 Select 操作之前记录当前时间 currentTimeNanos</li><li>time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos，如果事件轮询的持续时间大于等于 timeoutMillis，那么说明是正常的，否则表明阻塞时间并未达到预期，可能触发了空轮询的 Bug。（如何探测）</li><li>Netty 引入了计数变量 selectCnt。在正常情况下，selectCnt 会重置，否则会对 selectCnt 自增计数。当 selectCnt 达到 SELECTOR_AUTO_REBUILD_THRESHOLD（默认512） 阈值时，会触发重建 Selector 对象。（重建策略）</li></ol><h2><span id="其它任务处理">其它任务处理</span></h2><p>NioEventLoop 不仅负责处理 I/O 事件，还要兼顾执行任务队列中的任务。任务队列遵循 FIFO 规则，可以保证任务执行的公平性。NioEventLoop 处理的任务类型基本可以分为三类。</p><ol><li>普通任务：通过 NioEventLoop 的 execute() 方法向任务队列 taskQueue 中添加任务。例如 Netty 在写数据时会封装 WriteAndFlushTask 提交给 taskQueue。taskQueue 的实现类是多生产者单消费者队列 MpscChunkedArrayQueue，在多线程并发添加任务时，可以保证线程安全。</li><li>定时任务：通过调用 NioEventLoop 的 schedule() 方法向定时任务队列 scheduledTaskQueue 添加一个定时任务，用于周期性执行该任务。例如，心跳消息发送等。定时任务队列 scheduledTaskQueue 采用优先队列 PriorityQueue 实现。</li><li>尾部队列：tailTasks 相比于普通任务队列优先级较低，在每次执行完 taskQueue 中任务后会去获取尾部队列中任务执行。尾部任务并不常用，主要用于做一些收尾工作，例如统计事件循环的执行时间、监控信息上报等。</li></ol><p>NioEventLoop 处理任务的逻辑源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取即将可执行的定时任务，放入普通任务队列中</span></span><br><span class="line">        fetchFromScheduledTaskQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从普通任务队列中取出任务</span></span><br><span class="line">        Runnable task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterRunningAllTasks();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 计算任务处理超时时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">        <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 4. 执行任务（直接执行任务的 run 方法）</span></span><br><span class="line">            safeExecute(task);</span><br><span class="line"></span><br><span class="line">            runTasks ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 每执行 64 个任务，检查一下是否超时</span></span><br><span class="line">            <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            task = pollTask();</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 执行 tailTasks 队列中的任务，tailTasks 相比于普通任务队列优先级较低，主要用于做一些收尾工作，例如统计事件循环执行时间、监控信息上报等。</span></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="关于-eventloop-一些好的实践">关于 EventLoop 一些好的实践</span></h2><p>实际开发中，一些好的 EventLoop 实践：</p><ol><li>网络连接建立过程中三次握手、安全认证的过程会消耗不少时间，建议采用 Reactor 主从线程模型，MainReactor 线程处理客户端请求接入，SubReactor 线程：数据读取、I/O 事件的分发与执行。</li><li>由于 Reactor 线程模式适合处理耗时短的任务场景，对于耗时较长的 ChannelHandler 可以考虑维护一个<strong>业务线程池</strong>，将编解码后的数据封装成 Task 进行异步处理，避免 ChannelHandler 阻塞而造成 EventLoop 不可用。</li><li>如果业务逻辑执行时间较短，建议直接在 ChannelHandler 中执行。例如编解码操作，这样可以避免过度设计而造成架构的复杂性。</li><li>不宜设计过多的 ChannelHandler。对于系统性能和可维护性都会存在问题，在设计业务架构的时候，需要明确业务分层和 Netty 分层之间的界限。不要一味地将业务逻辑都添加到 ChannelHandler 中。</li></ol><h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.jianshu.com/p/3ec120ca46b2">JDK Epoll 空轮询 bug</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%</summary>
      
    
    
    
    <category term="Netty" scheme="https://shucunbin.github.io/categories/Netty/"/>
    
    
    <category term="事件循环" scheme="https://shucunbin.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Netty 前置知识点之 Reactor 反应器模式</title>
    <link href="https://shucunbin.github.io/2020/11/11/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%20Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shucunbin.github.io/2020/11/11/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%20Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-11T09:44:15.000Z</published>
    <updated>2022-01-29T02:47:58.857Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="概要">概要</span></h1><p>Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握  Nginx、Redis、Netty 这些中间件技术。总之，反应器模式是高性能网络编程的必知必会的模式。</p><h1><span id="什么是-reactor-反应器模式">什么是 Reactor 反应器模式</span></h1><p>Doug Lea 在 文章 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a> 中对反应器模式的定义：反应器模式由 Reactor 反应器线程、Handlers 处理器两大角色组成：</p><ul><li>Reactor 反应器线程的职责 - 负责响应 IO 事件，并且分发到 Handlers 处理器；</li><li>Handlers 处理器的职责：非阻塞的执行业务处理逻辑。</li></ul><h1><span id="reactor-反应器模式的演进">Reactor 反应器模式的演进</span></h1><h2><span id="connection-per-thread-模式">Connection Per Thread 模式</span></h2><p>Connection Per Thread，顾名思义，即对于每一个新的网络连接都分配一个线程，每个线程独立处理自己负责的输入和输出。当然，服务器的监听线程也是独立的，任何 socket 连接的输入和输出处理，不会阻塞后面新来连接的监听和建立。</p><p>Connection Per Thread 模式的优点是解决了前面的新连接被严重阻塞的问题，在一定程度上，极大地提高了服务器的吞吐量。<br>Connection Per Thread 模式的缺点是：对应于大量的连接，需要耗费大量的线程资源，在操作系统中，线程的创建、销毁、切换都需要不菲的代价。因此，在高并发的应用场景下，这种模式的缺陷是致命的。</p><h2><span id="单线程-recator-反应器模式">单线程 Recator 反应器模式</span></h2><p>为了解决 Connection Per Thread 模式的缺陷，我们使用 Reactor 反应器模式对线程的数量进行控制，做到<strong>一个线程处理大量的连接</strong>。<br>前面已经提到，在反应器模式中，有 Reactor 反应器和 Handler 处理器两个重要的组件：</p><ul><li>Reactor 反应器：负责查询 IO 事件，当检测到一个 IO 事件，将其发送给相应的 Handler 处理器去处理。<strong>这里的 IO 事件，就是 NIO 中选择器监控的通道 IO 事件</strong>。</li><li>Handler 处理器：与 IO 事件（或者选择键）绑定，负责 IO 事件的处理。<strong>完成真正的连接建立、通道数据的读取、处理业务逻辑、负责将结果写出到通道等</strong>。</li></ul><p>单线程 Reactor 反应器模式 指的是 Reactor 反应器和 Handlers 处理器处于一个线程中执行，它是最简单的反应器模型。基于 Java NIO 实现单线程  Reactor 反应器模式的核心 API 是类 SelectionKey 的以下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">attachment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其中，Handler 处理器实例将作为附件添加到 SelectionKey 实例中，当 IO 事件发生时，选择键被 select() 方法选到后，可以直接将事件处理器实例从附件取出，然后调用方法完成相应的处理。</p><p>单线程 Reactor反应器模式的缺点：<br>单线程 Reactor 反应器模式，是基于 Java 的 NIO 实现的，相对于传统的多线程 OIO，反应器模式不再需要启动很多线程，取而代之，Reactor 反应器和 Handler 处理器执行在同一条线程上，这样，带来了一个问题，<strong>当其中某个 Handler 阻塞时，会导致其它所有的 Handler 都得不到执行。在这种场景下，如果被阻塞的 Handler 不仅仅负责输入和输出处理的业务，还包括负责连接监听的 AcceptHandler 处理器，这个是非常严重的问题。一旦 AcceptHandler 处理器阻塞，会导致整个服务不能接收新的连接，使得服务器变得不可用。</strong>正因如此，在高性能服务器应用场景中，单线程反应器模式实际使用的很少。</p><h2><span id="多线程-recator-反应器模式">多线程 Recator 反应器模式</span></h2><p>针对单线程  Reactor 反应器的缺点，使用多线程，对基础反应器模式进行改造升级，即将负责输入输出的 Handler 处理器执行，放入独立的线程池中。这样，业务处理线程与负责监听和 IO 事件查询的反应器线程相互隔离，避免服务器的连接监听受到阻塞。<br>理论上，这种模式依然有一个地方是单点的，那就是处理客户端连接的线程。因为大多数服务端应用或多或少在连接时都会处理一些业务，如鉴权之类的，当连接的客户端越来越多时这一个线程依然会存在性能问题。</p><h2><span id="主从多线程的-reactor-反应器模式">主从多线程的 Reactor 反应器模式</span></h2><p>这种模式是在多线程 Reactor 反应器模式的基础上，将 Reactor 反应器拆分为多个子反应器线程，每一个 SubReactor 子线程负责一个选择器。这样可以充分使用系统处理能力，提高反应器管理连接的数量，提升选择大量通道的能力。</p><h1><span id="小结">小结</span></h1><h2><span id="反应器模式和生产者消费者模式对比">反应器模式和生产者消费者模式对比</span></h2><p>相似之处：在一定程度上，反应器模式有点类似生产者消费者模式。在生产者消费者模式中，一个或多个生产者将事件加入到一个队里中，一个或多个消费者主动地从这个队列中提取事件来处理。<br>不同之处：反应器模式是<strong>基于查询</strong>的，没有专门的队列去缓冲存储 IO 事件，查询到 IO 事件之后，反应器会根据不同 IO 选择键（事件）将其分发给对应的 Handler 处理。</p><h2><span id="反应器模式优缺点">反应器模式优缺点</span></h2><p>反应器模式优点：</p><ul><li>响应快，虽然同一反应器线程本身是同步的，但不会被单个连接的同步 IO 所阻塞；</li><li>编程相对简单，最大程度避免了复杂的多线程同步，也避免了多线程的切换的开销；</li><li>可扩展，可以方便地通过增加反应器线程的个数来充分利用 CPU 资源；</li></ul><p>反应器模式缺点：</p><ul><li>反应器模式增加了一定的复杂性，因而有一定的门槛，并且不易于调试；</li><li>反应器模式需要操作系统底层的 IO 多路复用的支持，如 Linux 中的 epoll，如果操作系统的底层不支持 IO 多路复用，反应器模式不会有那么高效；</li><li>同一个 Handler 业务线程中，如果出现一个长时间的数据读写，会影响这个反应器中其它通道的 IO 处理。因而，对于这种类型的处理，还需要进一步对反应器模式进行改进。</li></ul><h1><span id="参考资料">参考资料</span></h1><p>《Netty、Redis、Zookeeper 高并发实战》<br><a href="https://bbs.huaweicloud.com/blogs/266248?utm_source=zhihu&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">高性能网络框架：Reactor 和 Proactor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;概要&quot;&gt;概要&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握 </summary>
      
    
    
    
    <category term="Netty" scheme="https://shucunbin.github.io/categories/Netty/"/>
    
    
    <category term="线程模型" scheme="https://shucunbin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 之接口默认方法及静态方法</title>
    <link href="https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</id>
    <published>2019-07-11T09:44:15.000Z</published>
    <updated>2022-01-29T02:18:14.568Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概要">概要</span></h2><p>Java 8 新增了很多语言特性，其中涉及接口的有<strong>默认方法</strong>、<strong>静态方法</strong>，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员也同样适用。</p><p>静态方法旨在替代常见的伴生类，例如 Collection 类的伴生类 Collections 类、Path 类的半生类 Paths。</p><p>默认方法一来解决接口演化问题，二来替代抽象骨干类，例如 Collection 接口的抽象骨干类 AbstractCollection 类。</p><h2><span id="默认方法">默认方法</span></h2><p>默认方法，简而言之，就是在一个接口里使用 <code>default </code> 关键字定义的一个方法，所有该接口的实现类都可以直接使用而无须自己实现此方法。</p><p>默认方法存在的主要目的是为了方便扩展已有接口，如果没有默认方法，给一个已经发布的接口添加方法时，所有实现改接口的地方都得做修改，如果该接口的使用范围很广，那相应的影响也非常之大，例如 JDK 里定义的各种接口。因此，Java 8 中加入了此语言特性使得类库设计人员可以很方便的扩展已有的接口。</p><h3><span id="重写规则">重写规则</span></h3><p>实现包含默认方法的接口，有以下三种可能的方式：</p><ul><li>实现类不重写默认方法，直接使用接口中的默认方法；</li><li>子接口或抽象类将默认方法声明为普通的抽象方法；</li><li>实现类中重写默认方法，与重写普通的接口方法一样。</li></ul><p>如果使用代码片段描述这三种方式则如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        message(<span class="string">&quot;Parent: Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 不对默认方法做任何重写，直接使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 子接口或抽象类重新声明默认方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> BaseParent implements Parent &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实现类重写默认方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message(<span class="string">&quot;Child: Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个复杂的继承体系里，存在多个子类或子接口都重写了默认方法，到底哪个其作用呢？可以使用一句话简单概括其规则：<strong>类中重写的方法胜出。</strong>这样的设计主要是由增加默认方法的目的决定的，增加默认方法主要是为了在接口上向后兼容。让类中重写方法的优先级高于默认方法能简化很多继承问题</p><h3><span id="多重继承问题">多重继承问题</span></h3><p>接口允许多重继承，因此有可能碰到两个接口包含签名相同的默认方法的情况，如果一个类同时实现这两个接口，它到底该继承哪个接口的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, Foo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, Bar!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>,<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译失败，编译器提示：class FooBar inherits unrelated defaults for hello() from types Foo and Bar.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决此问题，我们需要显示的实现或声明 <code>hello()</code> 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>,<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现逻辑</span></span><br><span class="line">        <span class="keyword">return</span> Foo.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFooBar</span> <span class="keyword">implements</span> <span class="title">Foor</span>, <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="静态方法">静态方法</span></h2><p>我们在编程过程中，有时会将创建一些工具类，这些类里包含了大量的静态方法，例如 Objects 类、Collections 类等，这些工具方法，在语义上它们不具体属于某个类。但如果一个方法有充分的语义原因和某个概念相关，那么就应该将该方法和相关的类或接口放在一起，而不是放到另一个工具类中。</p><p>例如，Java 8 中引入的 <code>Stream</code> 接口，如果想创建一个由简单值组成的<code>Stream</code>，自然希望<code>Stream</code>接口就有一个这样的方法，而不是使用额外的工具类。这在以前很难达成，直到 Java 8 中为接口加入了静态方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料</span></h2><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">The Java™ Tutorials - Default Methods</a></p><p><a href="http://www.ituring.com.cn/book/1448">Java 8函数式编程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;概要&quot;&gt;概要&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Java 8 新增了很多语言特性，其中涉及接口的有&lt;strong&gt;默认方法&lt;/strong&gt;、&lt;strong&gt;静态方法&lt;/strong&gt;，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员</summary>
      
    
    
    
    <category term="Java 基础" scheme="https://shucunbin.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java 8" scheme="https://shucunbin.github.io/tags/Java-8/"/>
    
  </entry>
  
</feed>
