<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shucunbin&#39;s blog</title>
  
  
  <link href="https://shucunbin.github.io/atom.xml" rel="self"/>
  
  <link href="https://shucunbin.github.io/"/>
  <updated>2022-01-29T02:47:58.857Z</updated>
  <id>https://shucunbin.github.io/</id>
  
  <author>
    <name>shucunbin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty 前置知识点之 Reactor 反应器模式</title>
    <link href="https://shucunbin.github.io/2020/11/11/Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shucunbin.github.io/2020/11/11/Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-11T09:44:15.000Z</published>
    <updated>2022-01-29T02:47:58.857Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="概要">概要</span></h1><p>Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握  Nginx、Redis、Netty 这些中间件技术。总之，反应器模式是高性能网络编程的必知必会的模式。</p><h1><span id="什么是-reactor-反应器模式">什么是 Reactor 反应器模式</span></h1><p>Doug Lea 在 文章 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a> 中对反应器模式的定义：反应器模式由 Reactor 反应器线程、Handlers 处理器两大角色组成：</p><ul><li>Reactor 反应器线程的职责 - 负责响应 IO 事件，并且分发到 Handlers 处理器；</li><li>Handlers 处理器的职责：非阻塞的执行业务处理逻辑。</li></ul><h1><span id="reactor-反应器模式的演进">Reactor 反应器模式的演进</span></h1><h2><span id="connection-per-thread-模式">Connection Per Thread 模式</span></h2><p>Connection Per Thread，顾名思义，即对于每一个新的网络连接都分配一个线程，每个线程独立处理自己负责的输入和输出。当然，服务器的监听线程也是独立的，任何 socket 连接的输入和输出处理，不会阻塞后面新来连接的监听和建立。</p><p>Connection Per Thread 模式的优点是解决了前面的新连接被严重阻塞的问题，在一定程度上，极大地提高了服务器的吞吐量。<br>Connection Per Thread 模式的缺点是：对应于大量的连接，需要耗费大量的线程资源，在操作系统中，线程的创建、销毁、切换都需要不菲的代价。因此，在高并发的应用场景下，这种模式的缺陷是致命的。</p><h2><span id="单线程-recator-反应器模式">单线程 Recator 反应器模式</span></h2><p>为了解决 Connection Per Thread 模式的缺陷，我们使用 Reactor 反应器模式对线程的数量进行控制，做到<strong>一个线程处理大量的连接</strong>。<br>前面已经提到，在反应器模式中，有 Reactor 反应器和 Handler 处理器两个重要的组件：</p><ul><li>Reactor 反应器：负责查询 IO 事件，当检测到一个 IO 事件，将其发送给相应的 Handler 处理器去处理。<strong>这里的 IO 事件，就是 NIO 中选择器监控的通道 IO 事件</strong>。</li><li>Handler 处理器：与 IO 事件（或者选择键）绑定，负责 IO 事件的处理。<strong>完成真正的连接建立、通道数据的读取、处理业务逻辑、负责将结果写出到通道等</strong>。</li></ul><p>单线程 Reactor 反应器模式 指的是 Reactor 反应器和 Handlers 处理器处于一个线程中执行，它是最简单的反应器模型。基于 Java NIO 实现单线程  Reactor 反应器模式的核心 API 是类 SelectionKey 的以下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">attachment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其中，Handler 处理器实例将作为附件添加到 SelectionKey 实例中，当 IO 事件发生时，选择键被 select() 方法选到后，可以直接将事件处理器实例从附件取出，然后调用方法完成相应的处理。</p><p>单线程 Reactor反应器模式的缺点：<br>单线程 Reactor 反应器模式，是基于 Java 的 NIO 实现的，相对于传统的多线程 OIO，反应器模式不再需要启动很多线程，取而代之，Reactor 反应器和 Handler 处理器执行在同一条线程上，这样，带来了一个问题，<strong>当其中某个 Handler 阻塞时，会导致其它所有的 Handler 都得不到执行。在这种场景下，如果被阻塞的 Handler 不仅仅负责输入和输出处理的业务，还包括负责连接监听的 AcceptHandler 处理器，这个是非常严重的问题。一旦 AcceptHandler 处理器阻塞，会导致整个服务不能接收新的连接，使得服务器变得不可用。</strong>正因如此，在高性能服务器应用场景中，单线程反应器模式实际使用的很少。</p><h2><span id="多线程-recator-反应器模式">多线程 Recator 反应器模式</span></h2><p>针对单线程  Reactor 反应器的缺点，使用多线程，对基础反应器模式进行改造升级，即将负责输入输出的 Handler 处理器执行，放入独立的线程池中。这样，业务处理线程与负责监听和 IO 事件查询的反应器线程相互隔离，避免服务器的连接监听受到阻塞。<br>理论上，这种模式依然有一个地方是单点的，那就是处理客户端连接的线程。因为大多数服务端应用或多或少在连接时都会处理一些业务，如鉴权之类的，当连接的客户端越来越多时这一个线程依然会存在性能问题。</p><h2><span id="主从多线程的-reactor-反应器模式">主从多线程的 Reactor 反应器模式</span></h2><p>这种模式是在多线程 Reactor 反应器模式的基础上，将 Reactor 反应器拆分为多个子反应器线程，每一个 SubReactor 子线程负责一个选择器。这样可以充分使用系统处理能力，提高反应器管理连接的数量，提升选择大量通道的能力。</p><h1><span id="小结">小结</span></h1><h2><span id="反应器模式和生产者消费者模式对比">反应器模式和生产者消费者模式对比</span></h2><p>相似之处：在一定程度上，反应器模式有点类似生产者消费者模式。在生产者消费者模式中，一个或多个生产者将事件加入到一个队里中，一个或多个消费者主动地从这个队列中提取事件来处理。<br>不同之处：反应器模式是<strong>基于查询</strong>的，没有专门的队列去缓冲存储 IO 事件，查询到 IO 事件之后，反应器会根据不同 IO 选择键（事件）将其分发给对应的 Handler 处理。</p><h2><span id="反应器模式优缺点">反应器模式优缺点</span></h2><p>反应器模式优点：</p><ul><li>响应快，虽然同一反应器线程本身是同步的，但不会被单个连接的同步 IO 所阻塞；</li><li>编程相对简单，最大程度避免了复杂的多线程同步，也避免了多线程的切换的开销；</li><li>可扩展，可以方便地通过增加反应器线程的个数来充分利用 CPU 资源；</li></ul><p>反应器模式缺点：</p><ul><li>反应器模式增加了一定的复杂性，因而有一定的门槛，并且不易于调试；</li><li>反应器模式需要操作系统底层的 IO 多路复用的支持，如 Linux 中的 epoll，如果操作系统的底层不支持 IO 多路复用，反应器模式不会有那么高效；</li><li>同一个 Handler 业务线程中，如果出现一个长时间的数据读写，会影响这个反应器中其它通道的 IO 处理。因而，对于这种类型的处理，还需要进一步对反应器模式进行改进。</li></ul><h1><span id="参考资料">参考资料</span></h1><p>《Netty、Redis、Zookeeper 高并发实战》<br><a href="https://bbs.huaweicloud.com/blogs/266248?utm_source=zhihu&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">高性能网络框架：Reactor 和 Proactor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;概要&quot;&gt;概要&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握 </summary>
      
    
    
    
    <category term="Netty" scheme="https://shucunbin.github.io/categories/Netty/"/>
    
    
    <category term="线程模型" scheme="https://shucunbin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 之接口默认方法及静态方法</title>
    <link href="https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</id>
    <published>2019-07-11T09:44:15.000Z</published>
    <updated>2022-01-29T02:18:14.568Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概要">概要</span></h2><p>Java 8 新增了很多语言特性，其中涉及接口的有<strong>默认方法</strong>、<strong>静态方法</strong>，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员也同样适用。</p><p>静态方法旨在替代常见的伴生类，例如 Collection 类的伴生类 Collections 类、Path 类的半生类 Paths。</p><p>默认方法一来解决接口演化问题，二来替代抽象骨干类，例如 Collection 接口的抽象骨干类 AbstractCollection 类。</p><h2><span id="默认方法">默认方法</span></h2><p>默认方法，简而言之，就是在一个接口里使用 <code>default </code> 关键字定义的一个方法，所有该接口的实现类都可以直接使用而无须自己实现此方法。</p><p>默认方法存在的主要目的是为了方便扩展已有接口，如果没有默认方法，给一个已经发布的接口添加方法时，所有实现改接口的地方都得做修改，如果该接口的使用范围很广，那相应的影响也非常之大，例如 JDK 里定义的各种接口。因此，Java 8 中加入了此语言特性使得类库设计人员可以很方便的扩展已有的接口。</p><h3><span id="重写规则">重写规则</span></h3><p>实现包含默认方法的接口，有以下三种可能的方式：</p><ul><li>实现类不重写默认方法，直接使用接口中的默认方法；</li><li>子接口或抽象类将默认方法声明为普通的抽象方法；</li><li>实现类中重写默认方法，与重写普通的接口方法一样。</li></ul><p>如果使用代码片段描述这三种方式则如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        message(<span class="string">&quot;Parent: Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 不对默认方法做任何重写，直接使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 子接口或抽象类重新声明默认方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> BaseParent implements Parent &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实现类重写默认方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message(<span class="string">&quot;Child: Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个复杂的继承体系里，存在多个子类或子接口都重写了默认方法，到底哪个其作用呢？可以使用一句话简单概括其规则：<strong>类中重写的方法胜出。</strong>这样的设计主要是由增加默认方法的目的决定的，增加默认方法主要是为了在接口上向后兼容。让类中重写方法的优先级高于默认方法能简化很多继承问题</p><h3><span id="多重继承问题">多重继承问题</span></h3><p>接口允许多重继承，因此有可能碰到两个接口包含签名相同的默认方法的情况，如果一个类同时实现这两个接口，它到底该继承哪个接口的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, Foo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, Bar!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>,<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译失败，编译器提示：class FooBar inherits unrelated defaults for hello() from types Foo and Bar.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决此问题，我们需要显示的实现或声明 <code>hello()</code> 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>,<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现逻辑</span></span><br><span class="line">        <span class="keyword">return</span> Foo.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFooBar</span> <span class="keyword">implements</span> <span class="title">Foor</span>, <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="静态方法">静态方法</span></h2><p>我们在编程过程中，有时会将创建一些工具类，这些类里包含了大量的静态方法，例如 Objects 类、Collections 类等，这些工具方法，在语义上它们不具体属于某个类。但如果一个方法有充分的语义原因和某个概念相关，那么就应该将该方法和相关的类或接口放在一起，而不是放到另一个工具类中。</p><p>例如，Java 8 中引入的 <code>Stream</code> 接口，如果想创建一个由简单值组成的<code>Stream</code>，自然希望<code>Stream</code>接口就有一个这样的方法，而不是使用额外的工具类。这在以前很难达成，直到 Java 8 中为接口加入了静态方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料</span></h2><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">The Java™ Tutorials - Default Methods</a></p><p><a href="http://www.ituring.com.cn/book/1448">Java 8函数式编程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;概要&quot;&gt;概要&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Java 8 新增了很多语言特性，其中涉及接口的有&lt;strong&gt;默认方法&lt;/strong&gt;、&lt;strong&gt;静态方法&lt;/strong&gt;，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员</summary>
      
    
    
    
    <category term="Java 基础" scheme="https://shucunbin.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java 8" scheme="https://shucunbin.github.io/tags/Java-8/"/>
    
  </entry>
  
</feed>
