<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shucunbin&#39;s blog</title>
  
  
  <link href="https://shucunbin.github.io/atom.xml" rel="self"/>
  
  <link href="https://shucunbin.github.io/"/>
  <updated>2022-01-29T07:01:59.552Z</updated>
  <id>https://shucunbin.github.io/</id>
  
  <author>
    <name>shucunbin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Security 学习札记（三）：认证</title>
    <link href="https://shucunbin.github.io/2021/11/14/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AE%A4%E8%AF%81/"/>
    <id>https://shucunbin.github.io/2021/11/14/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%AE%A4%E8%AF%81/</id>
    <published>2021-11-14T09:30:15.000Z</published>
    <updated>2022-01-29T07:01:59.552Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="支持的认证机制">支持的认证机制</span></h1><p>Spring Security  集成的主流认证机制包括：</p><ul><li>表单认证</li><li>OAuth2.0 认证</li><li>HTTP Basic 认证</li><li>HTTP Digest 认证</li><li>OpenID 去中性化认证</li><li>RememberMe 自动认证</li><li>SAML 2.0 认证</li><li>CAS 认证</li><li>JAAS 认证</li><li>Pre-Authentication Scenarios 认证</li><li>X509 认证</li><li>自定义认证逻辑</li></ul><h1><span id="关键概念及流程">关键概念及流程</span></h1><p>Authentication、AuthenticationProvider、AuthenticationManager（实现类为 ProviderManager）。<br>在一次完整的认证流程中，可能会同时存在多个 AuthenticationProvider，多个 AuthenticationProvider 统一由 ProviderManager 来管理。同时 ProviderManager 具有一个 parent，它是一个备选认证方式，当所有认证都失败了，就由 parent 出场收拾残局。</p><h2><span id="authentication">Authentication</span></h2><p>Authentication 对象主要有两方面的功能：</p><ul><li>作为 AuthenticationManager 的输入参数，提供用户认证的凭证，当它作为一个输入参数时，它的 isAuthenticated 方法返回 false，表示用户还未认证。</li><li>代表已经经过身份认证的用户，此时的 Authentication 可以从 SecurityContext 中获取。</li></ul><p>一个 Authentication 对象主要包含三个方面的信息：</p><ul><li>principal：定义认证的用户，如果用户使用用户名/密码的方式登陆，principal 通常就是一个 UserDetails 对象；</li><li>credentials：登陆凭证，一般就是指密码。当用户登陆成功之后，登陆凭证会被自动擦除，以防止泄漏；</li><li>authorities：用户被授予的权限信息。</li></ul><p>常见的 Authentication 实现类：</p><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>AbstractAuthenticationToken</td><td>实现了 Authentication、CredentialsContainer 两个接口，其中 CredentialsContainer 提供了登陆凭证擦除方法。一般登陆成功后，为了防止用户信息泄漏，可以将登陆凭证擦除。</td></tr><tr><td>RememberMeAuthenticationToken</td><td>使用 RememberMe 登陆时，存储登陆信息</td></tr><tr><td>TestingAuthenticationToken</td><td>单元测试时封装的用户对象</td></tr><tr><td>AnonymousAuthenticationToken</td><td>匿名登录时封装用户对象</td></tr><tr><td>RunAsUserToken</td><td>替换验证身份时封装的用户对象</td></tr><tr><td>UsernamePasswordAuthenticationToken</td><td>表单登陆时封装的用户对象</td></tr><tr><td>JaasAuthenticationToken</td><td>JAAS 认证时封装的用户对象</td></tr><tr><td>PreAuthenticatedAuthenticationToken</td><td>Pre-Authentication 场景下封装的用户对象</td></tr></tbody></table><h2><span id="securitycontextholder">SecurityContextHolder</span></h2><p>SecurityContextHolder 中存储的是 SecurityContext，SecurityContext 中存储的是 Authentication。SecurityContext 的存储方式由 SecurityContextHolderStrategy 决定，目前存在三种类型的 SecurityContextHolderStrategy，分别为：</p><ul><li>ThreadLocalSecurityContextHolderStrategy （默认）</li><li>InheritableThreadLocalSecurityContextHolderStrategy</li><li>GlobalSecurityContextHolderStrategy</li></ul><p>还有一个 与SecurityContext 相关的重要过滤器  <code> SecurityContextPersistenceFilter</code>，它的作用是为了存储 SecurityContext 而设计的，主要做两件事情：</p><ul><li>请求来的时候，从 HttpSession 中获取 SecurityContext 并存例入 SecurityContextHolder 中，这样在同一个请求的后续处理过程中，开发者始终可以通过 SecurityContextHolder 获取当前登陆用户信息。</li><li>当一个请求处理完毕时，从 SecurityContextHolder 中获取 SecurityContext 并存入 HttpSession 中（主要针对异步 Servlet），方便下一个请求到来时，再从 HttpSession 中拿出来使用，同时擦除 SecurityContextHolder 中的登陆用户信息。</li></ul><p>上述两部操作均有 <code>SecurityContextRepository</code> 接口完成，它的三个实现类为：</p><ul><li>NullSecurityContextRepository（什么都没做）</li><li>TestSecurityContextRepository（为单元测试提供支持）</li><li>HttpSessionSecurityContextRepository（默认）</li></ul><h2><span id="authenticationmanager">AuthenticationManager</span></h2><p>AuthenticationManager 是一个认证管理器，它定义了 Spring Security 过滤器要如何执行认证操作。AuthenticationManager 在认证成功后，会返回一个 Authentication 对象，这个 Authentication 对象会被设置到 SecurityContextHolder 中。</p><p>ProviderManager  是 AuthenticationManager 的一个重要实现类。ProviderManager 和 AuthenticationProvider 之间的关系如下图：<br><img src="https://thumbimg.dealmoon.com/dealmoon/7ef/fc3/4a4/061532f33222e1bdd60a807.jpg"><br>多个 AuthenticationProvider 将组成一个列表，这个列表将由 ProviderManager 代理，换而言之，在 ProviderManager 中存在一个 AuthenticationProvider 列表，在 ProviderManager 中遍历列表中的每一个 AuthenticationProvider 去执行身份认证，最终得到认证结果。<br>ProviderManager 本身也可以再配置一个 AuthenticationProvider 作为 parent，这样当 ProviderManager 失败之后，就可以进入 parent 中再次进行认证。ProviderManager 的 parent 可以是任意类型的 AuthenticationManager。<br>ProviderManager 本身也可以有多个，多个 ProviderManager 共用一个 parent，当存在多个过滤器链的时候非常有用。当存在多个过滤器链时，不同的路径可能对应不同的认证方式，但是不同路径可能又会同时存在一些共有的认证方式，这些共有的认证方式可以在 parent 中统一处理。</p><h3><span id="全局-providermanager-与-局部-providermanager-的配置">全局 ProviderManager 与 局部 ProviderManager 的配置</span></h3><p>一个系统中，我们可以配置多个 HttpSecurity，而mei每一个HttpSecurity 都有一个对应的 AuthenticationManager，我们暂且称这种 AuthenticationManager 为局部 AuthenticationManager，这些局部的 AuthenticationManager 实例都有一个共同的 parent，那就是全局的 AuthenticationManager。<br>待补充</p><h2><span id="abstractauthenticationprocessingfilter">AbstractAuthenticationProcessingFilter</span></h2><p>作为 Spring Security 过滤器链中的一环，<code>AbstractAuthenticationProcessingFilter</code> 将 Authentication、AuthenticationManager（ProviderManager）、AuthenticationProvider 这些组件与登陆关联起来，它可以用来处理任何提交给它的身份认证。下图是 <code>AbstractAuthenticationProcessingFilter</code> 在整个通用架构中所处的位置：<br><img src="https://thumbimg.dealmoon.com/dealmoon/325/61d/58b/2b6f4481e468d79eb9660e6.jpg"></p><p><code>AbstractAuthenticationProcessingFilter</code> 作为一个抽象类，使用不同的方式登陆，对应不同的实现类。比如，如果使用用户名/密码的方式登陆，那么它对应的实现类是 <code>UsernamePasswordAuthenticationFilter</code>，构造出来的 Authentication 对象则是 <code>UsernamePasswordAuthenticationToken</code>。其大致流程如下：</p><ul><li>当用户提交登陆请求时，UsernamePasswordAuthenticationFilter 会从当前请求 HttpServletRequest 中提取出登陆用户名/密码，然后创建出一个 UsernamePasswordAuthenticationToken 对象。</li><li>UsernamePasswordAuthenticationToken 对象将被传入 ProviderManager 中进行具体的认证操作。</li><li>如果认证失败，则 SecurityContextHolder 中相关信息将被清除，登陆失败回调也会被调用。</li><li>如果认证成功，则会进行登陆信息存储、Session 并发处理、登陆成功事件发布以及登陆成功方法回调等。</li></ul><h2><span id="rememberme">RememberMe</span></h2><p>RememberMe 是一种服务器端的行为，具体的思路就是通过 Cookie 来记录当前用户身份。当用户登陆成功后，会通过一定的算法，将用户信息、时间戳等进行加密，加密完成后，通过响应头带回前端存储在 Cookie 中，当浏览器关闭之后重新打开，如果再次访问该网站，会自动将 Cookie 中的信息发送给服务器，服务器对 Cookie 中的信息进行校验分析，进而确定用户身份。</p><p>为了提高普通令牌的安全性，在其基础上的改进方案包括：持久化令牌、二次校验</p><h3><span id="持久化令牌">持久化令牌</span></h3><p>在普通令牌的基础上，新增了 series 和 token 两个校验参数，当使用用户名/密码的方式登陆时，series 才会自动更新，而一旦有了新的会话，token 就会重新生成。所以，如果令牌被别人盗用，对方使用 RememberMe 登陆成功后，就会生成新的 token，你自己的登陆令牌就会失效，这样就能及时发现账户泄漏并作出处理，比如清除自动登陆令牌、通知账户泄漏等。<br>建立新会话的场景：关闭浏览器再重新打开、重启服务器</p><h3><span id="二次校验">二次校验</span></h3><p>二次校验就是将系统中的资源分为敏感的和不敏感的，如果用户使用了 RememberMe 的方式登陆，这访问敏感资源时会自动跳转到登陆页面，要求用户重新登陆；如果使用了用户名/密码的方式登陆，则可以访问所有资源。这种方式相当于牺牲了一点用户体验换取系统安全性。</p><h3><span id="原理关键-api">原理关键 API</span></h3><ul><li>RememberMeServices，定义自动登陆逻辑、设置 cookie 逻辑</li><li>RememberMeConfigurer，开启 RememberMe 功能的配置类，init() 方法中集成了 RememberMeServices、RememberMeAuthenticationProvider，configure() 方法中配置了 RememberAuthenticationFilter。</li><li>RememberMeAuthenticationFilter，将 RememberMe 功能集成到系统的 Filter。</li><li>RememberMeAuthenticationToken，RememberMeAuthenticationProvider 认证成功后返回的 Authentication 实现类。</li></ul><blockquote><p>什么是 HttpOnly？<br>如果 cookie 中设置了 HttpOnly 属性，那么 JS 脚步将无法读取到 cookie 信息，这样能有效防止 XSS 攻击，获取 cookie 内容。XSS 全称 Cross SiteScript，跨站脚本攻击，是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式，其原理是攻击者向有 XSS 漏洞的网站中输入恶意的 HTML 代码，当其它用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的，如盗取用户 Cookie、破坏页面结构、重定向到其它网站等。</p></blockquote><h2><span id="会话管理">会话管理</span></h2><p>当浏览器调用登陆接口成功后，服务器端会和浏览器之间建立一个会话（Session），浏览器在每次发送请求时都会携带一个 sessionId通过 cookie或 url 重写），服务端则根据这个 sessionId 来确定用户的身份。当浏览器关闭后，服务端的 Session 并不会自动销毁，需要开发者手动在服务端调用 Session 销毁方法，或者等 Session 过期自动销毁。</p><h3><span id="会话并发管理">会话并发管理</span></h3><p>会话并发管理就是在当前系统中，同一个用户可以同时创建多少个会话，如果一台设备对应一个会话，那么也可以简单理解为同一个用户可以同时在多少台设备进行登陆。默认情况下，同一用户在多少台设备上登陆并没有限制，开发者可执行配置。</p><p>通过配置可以实现相同的用户同时只可以登陆一台设备：相互踢或者禁止后面的设备登陆。</p><h3><span id="原理关键-api">原理关键 API</span></h3><ul><li>SessionInformation，记录 Spring Security 框架内的会话信息。</li><li>SessionRegistry，用来维护 SessionInformation 实例</li><li>SessionAuthenticationStrategy，用作在用户登陆成功后，对 HttpSession 进行处理，它有很多作用各异的实现类。<ul><li>CsrfAuthenticationStrategy，与 CSRF 攻击有关，该类主要负责在身份验证后删除旧的 CstfToken 并生成一个新的 CsrfToken；</li><li>ConcurrentSessionControlAuthenticationStrategy，处理 Session 并发问题；</li><li>RegisterSessionAuthenticationStrategy，用于在认证成功后将 HttpSession 信息记录到 SessionRegistry 中；</li><li>CompositeSessionAuthenticationStrategy，复合策略，Spring Security 使用的就是该类的实例；</li><li>NullAuthenticationSessionStrategy：空实现；</li><li>AbstractSessionFixationProtectionStrategy：处理会话固定攻击的基类；</li><li>ChangeSessionIdAuthenticationStrategy：通过修改 sessionId 来防止会话攻击；</li><li>SessionFixationProtectionStrategy：通过创建一个新的会话来防止会话固定攻击。</li></ul></li><li>SessionManagementFilter，用来处理 RememberMe 登陆时的会话管理，即如果用户使用了 RememberMe 的方式进行认证，则认证成功后需要进行会话管理，相关的管理操作通过 SessionManagementFilter 过滤器触发。</li><li>ConcurrentSessionFilter，处理会话并发管理</li><li>SessionManagementConfigurer，完成 SessionManagementFilter、ConcurrentSessionFilter 的配置。</li><li>AbstractAuthenticationProcessingFilter，认证成功后，调用 sessionStrategy 的 onAuthentication方法</li></ul><p>整个流程总结：用户通过用户名／密码发起一个认证请求，当认证成功后，在 AbstractAuthenticationProcessingFilter#doFilter方法中触发了Session并发管理。默认的 sessionStrategy是Composite SessionAuthenticationStrategy，它一共代理了三个 SessionAuthenticationStrategy，分别是ConcurrentSessionControlAuthenticationStrategy、ChangeSessionIdAuthenticationStrategy以及RegisterSessionAuthenticationStrategy。当前请求在这三个SessionAuthenticationStrategy中分别走一圈，第一个用来判断当前登录用户的Session数是否已经超出限制，如果超出限制就根据配置好的规则作出处理；第二个用来修改sessionId（防止会话固定攻击）；第三个用来将当前Session注册到SessionRegistry中。使用用户名／密码的方式完成认证，将不会涉及ConcurrentSessionFilter和SessionManagementFilter两个过滤器。如果用户使用了RememberMe的方式来进行身份认证，则会通过SessionManagementFilter#doFilter方法触发Session并发管理。当用户认证成功后，以后的每一次请求都会经过ConcurrentSessionFilter，在该过滤器中，判断当前会话是否已经过期，如果过期就执行注销登录流程；如果没有过期，则更新最近一次请求时间。</p><h3><span id="会话固定攻击与防御">会话固定攻击与防御</span></h3><p>会话固定攻击（Session fixation attacks）是一种潜在的风险，恶意攻击者有可能通过访问当前应用程序创建会话，然后诱导用户<strong>以相同的会话 ID 登陆</strong>，通常是将会话ID作为参数放在请求链接中，然后诱导用户去点击，进而获取用户的登陆身份。</p><p>三个方面入手防范会话固定攻击：</p><ul><li>Spring Security 中默认自带了 Http 防火墙，如果 sessionid 放在地址栏中，这个请求就会直接被拦截下来；</li><li>在 Http 响应的 set-cookie 字段中设置 httpOnly 属性，避免通过 XSS 攻击来获取包含sessionid 的 Cookie 信息；</li><li>用户登陆成功后，改变会话 sessionid，Spring Security 默认实现来该种方案。</li></ul><h3><span id="会话共享">会话共享</span></h3><p>集群环境下的会话共享解决方案：</p><ul><li>Session 复制：多个服务之间互相复制 session 信息，这样每个服务中都包含来所有的 session 信息，Tomcat 通过 IP 组播对这种方案提供支持。但是这种方案占用宽带、有时延，服务数量越多效率越低，所以这种方案使用较少；</li><li>Session 粘滞：也叫会话保持，就是在 Nginx 上通过一致性 Hash，将 Hash 结果相同的请求总是分发到一个服务上去。这种方案可以解决一部分集群会话带来的问题，但是无法解决集群中的会话并发管理问题。</li><li>Session 共享：Session 共享就是将不同服务的会话统一放在一个地方，所有的服务共享一个会话。一般使用redis 等key-value 数据库存储 session。</li></ul><p>使用 redis 维护 session 的信息关键类是 spring-session 的 SessionRepositoryFilter。</p><h1><span id="参考文章">参考文章</span></h1><p><a href="https://www.cnblogs.com/zongmin/p/13783348.html">session 会话管理</a><br><a href="https://www.cnblogs.com/54chensongxia/p/12096493.html">@EnableRedisHttpSession原理简析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;支持的认证机制&quot;&gt;支持的认证机制&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Spring Security  集成的主流认证机制包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表单认证&lt;/li&gt;
&lt;li&gt;OAuth2.0 认证&lt;/li&gt;
&lt;li&gt;HTTP Basic 认证&lt;/li</summary>
      
    
    
    
    <category term="Spring Security" scheme="https://shucunbin.github.io/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="https://shucunbin.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 学习札记（二）：登陆用户数据</title>
    <link href="https://shucunbin.github.io/2021/11/13/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%99%BB%E9%99%86%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE/"/>
    <id>https://shucunbin.github.io/2021/11/13/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%99%BB%E9%99%86%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE/</id>
    <published>2021-11-13T09:30:15.000Z</published>
    <updated>2022-01-29T06:57:42.266Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="保存登陆用户">保存登陆用户</span></h1><p>如果使用 Spring Security 这一类安全管理框架，大部分的开发者可能会将登陆用户数据保存在 Session 中，事实上，Spring Security 也是这么做的，并在此基础上做了一些改进，其中最主要的一个变化就是线程绑定。<br>当用户登陆成功后，Spring Security 会将登陆成功的用户信息保存到 SecurityContextHolder 中，SecurityContextHolder 中的数据保存默认是通过 ThreadLocal 来实现的，使用 ThreadLocal 创建的变量只能被当前线程访问，不能被其它线程访问和修改，也就是用户数据和请求线程绑定在一起。当登陆请求处理完毕后，Spring Security 会将 SecurityContextHolder 中的数据拿出来保存到 Session 中，同时将 SecurityContextHolder 中的数据清空。以后每当有请求到来时，Spring Security 就会从 Session 中取出用户登陆数据，保存到 SecurityContextHolder 中，方便在该请求的后续护理过程中使用，同时在请求结束时将 SecurityContextHolder 中的数据拿出来保存到 session 中，然后将 SecurityContextHolder 的数据清空。<br>这种策略在子线程中想要获取用户登陆数据时比较麻烦，Spring Security 对此也提供来相应的解决方案，如果开发者使用 <code>@Async</code> 注解来开启异步任务的话，那么只需要添加如下配置，使用 Spring Security 提供的异步任务代理，就可以在异步任务中从 SecurityContextHolder 里边获取当前登陆用户的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatingSecurityContextExecutorService(Executors.newFixedThreadPool(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="获取登陆用户">获取登陆用户</span></h1><p>登陆用户获取主要分为两种方式：</p><ul><li>从 SecurityContextHolder 中获取</li><li>从当前请求对象中获取</li></ul><h2><span id="从-securitycontextholder-中获取">从 SecurityContextHolder 中获取</span></h2><h3><span id="authentication">Authentication</span></h3><p>登陆用户信息使用 Authentication 对象表示，Authentication 对象主要有两方面的功能：</p><ul><li>作为 AuthenticationManager 的输入参数，提供用户认证的凭证，当它作为一个输入参数时，它的 isAuthenticated 方法返回 false，表示用户还未认证。</li><li>代表已经经过身份认证的用户，此时的 Authentication 可以从 SecurityContext 中获取。</li></ul><p>一个 Authentication 对象主要包含三个方面的信息：</p><ul><li>principal：定义认证的用户，如果用户使用用户名/密码的方式登陆，principal 通常就是一个 UserDetails 对象；</li><li>credentials：登陆凭证，一般就是指密码。当用户登陆成功之后，登陆凭证会被自动擦除，以防止泄漏；</li><li>authorities：用户被授予的权限信息。</li></ul><p>常见的 Authentication 实现类：</p><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>AbstractAuthenticationToken</td><td>实现了 Authentication、CredentialsContainer 两个接口，其中 CredentialsContainer 提供了登陆凭证擦除方法。一般登陆成功后，为了防止用户信息泄漏，可以将登陆凭证擦除。</td></tr><tr><td>RememberMeAuthenticationToken</td><td>使用 RememberMe 登陆时，存储登陆信息</td></tr><tr><td>TestingAuthenticationToken</td><td>单元测试时封装的用户对象</td></tr><tr><td>AnonymousAuthenticationToken</td><td>匿名登录时封装用户对象</td></tr><tr><td>RunAsUserToken</td><td>替换验证身份时封装的用户对象</td></tr><tr><td>UsernamePasswordAuthenticationToken</td><td>表单登陆时封装的用户对象</td></tr><tr><td>JaasAuthenticationToken</td><td>JAAS 认证时封装的用户对象</td></tr><tr><td>PreAuthenticatedAuthenticationToken</td><td>Pre-Authentication 场景下封装的用户对象</td></tr></tbody></table><h3><span id="securitycontextholder">SecurityContextHolder</span></h3><p>SecurityContextHolder 中存储的是 SecurityContext，SecurityContext 中存储的是 Authentication。SecurityContext 的存储方式由 SecurityContextHolderStrategy 决定，目前存在三种类型的 SecurityContextHolderStrategy，分别为：</p><ul><li>ThreadLocalSecurityContextHolderStrategy （默认）</li><li>InheritableThreadLocalSecurityContextHolderStrategy</li><li>GlobalSecurityContextHolderStrategy</li></ul><p>还有一个 与SecurityContext 相关的重要过滤器  <code> SecurityContextPersistenceFilter</code>，它的作用是为了存储 SecurityContext 而设计的，主要做两件事情：</p><ul><li>请求来的时候，从 HttpSession 中获取 SecurityContext 并存例入 SecurityContextHolder 中，这样在同一个请求的后续处理过程中，开发者始终可以通过 SecurityContextHolder 获取当前登陆用户信息。</li><li>当一个请求处理完毕时，从 SecurityContextHolder 中获取 SecurityContext 并存入 HttpSession 中（主要针对异步 Servlet），方便下一个请求到来时，再从 HttpSession 中拿出来使用，同时擦除 SecurityContextHolder 中的登陆用户信息。</li></ul><p>上述两部操作均有 <code>SecurityContextRepository</code> 接口完成，它的三个实现类为：</p><ul><li>NullSecurityContextRepository（什么都没做）</li><li>TestSecurityContextRepository（为单元测试提供支持）</li><li>HttpSessionSecurityContextRepository（默认）</li></ul><h2><span id="从当前请求对象中获取">从当前请求对象中获取</span></h2><p>直接在 Controller 的请求参数中放入 Authentication 或 Principal 对象获取，本质上，这些对象都是 HttpServletRequest 带来的（通过 <code>ServletRequestMethodArgumentResolver</code>），在使用了 Spring Security 框架时，HttpServletRequest 的实现类为 <code>Servlet3SecurityContextHolderAwareRequestWrapper</code>。<br>Spring Security 使用 <code>SecurityContextHolderAwareRequestFilter </code>过滤器将默认的请求对象转化为 Servlet3SecurityContextHolderAwareRequestWrapper。</p><h1><span id="定义登陆用户的其它方式">定义登陆用户的其它方式</span></h1><p>Spring Security 支持多种用户定义的方式，其抽象接口为 <code>UserDetailsService</code>，其不同的实现类表示不同的用户定义方式，将配置好的 UserDetailsService 提供给 AuthenticationManagerBuilder，系统再将 UserDetailsService 提供给 AuthenticationProvider 使用。</p><h2><span id="基于内存">基于内存</span></h2><p>我们使用配置文件配置用户时，本质上就是基于内存，对应的实现类为 <code>InMemoryUserDetailsManager</code>。</p><h2><span id="基于-jdbcuserdetailsmanager">基于 JdbcUserDetailsManager</span></h2><p>JdbcUserDetailsManager 支持将用户数据持久化到数据库，同时它还封装类一系列操作用户的方法，例如用户的添加、更新、查找等。<br>Spring Security 中为 <code>JdbcUserDetailsManager</code> 提供了数据库脚本（无法自定义用户表、角色表等，这意味着这种方式的局限性很大），位置在 org/springframework/security/core/userdetails/jdbc/users.ddl。</p><h2><span id="基于-mybatis">基于 MyBatis</span></h2><p>使用 MyBatis 做数据持久化是目前大多数企业应用采用的方案，Spring Security 中结合 MyBatis 可以灵活地定制用户表以及角色表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;保存登陆用户&quot;&gt;保存登陆用户&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;如果使用 Spring Security 这一类安全管理框架，大部分的开发者可能会将登陆用户数据保存在 Session 中，事实上，Spring Security 也是这么做的，并在此基础上做了</summary>
      
    
    
    
    <category term="Spring Security" scheme="https://shucunbin.github.io/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="https://shucunbin.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 学习札记（一）：基本概念</title>
    <link href="https://shucunbin.github.io/2021/11/12/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://shucunbin.github.io/2021/11/12/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2021-11-12T09:30:15.000Z</published>
    <updated>2022-01-29T06:50:40.072Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="概述">概述</span></h1><p>Spring Security，这是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。在 Spring Framework 基础上，Spring Security 充分利用了依赖注入（DI，Dependency Injection）和面向切面技术。</p><h1><span id="实现机制">实现机制</span></h1><p>在 Sping Security 中，认证、授权等功能都是基于过滤器来完成的。以下是常见的过滤器，这里的是否默认加载指的是引入 Spring Security 依赖之后，开发者不做任何配置时，会自动加载的过滤器：</p><table><thead><tr><th>过滤器</th><th>过滤器作用</th><th>是否默认加载</th></tr></thead><tbody><tr><td>ChannelProcessingFilter</td><td>过滤请求协议，如 HTTPS 和 HTTP</td><td>NO</td></tr><tr><td>WebAsyncManagerIntegrationFilter</td><td>将 WebAsyncManager 与 Spring Security 上下文进行集成</td><td>YES</td></tr><tr><td>SecurityContextPersistenceFilter</td><td>在处理请求之前，将安全信息加载到 SecurityContextHolder中以方便后续使用。请求结束后，再擦除 SecurityContextHolder 中的信息</td><td>YES</td></tr><tr><td>HeaderWriterFilter</td><td>头信息加入响应中</td><td>YES</td></tr><tr><td>CorsFilter</td><td>处理跨域问题</td><td>NO</td></tr><tr><td>CsrfFilter</td><td>处理 CSRF 攻击</td><td>YES</td></tr><tr><td>LogoutFilter</td><td>处理注销登陆</td><td>YES</td></tr><tr><td>OAuth2AuthorizationRequestRedirectFilter</td><td>处理 OAuth2 认证重定向</td><td>NO</td></tr><tr><td>Saml2WebSsoAuthenticationRequestFilter</td><td>处理 SAML 认证</td><td>NO</td></tr><tr><td>X509AuthenticationFilter</td><td>处理 X509 认证</td><td>NO</td></tr><tr><td>AbstractPreAuthenticationFilter</td><td>处理预认证问题</td><td>NO</td></tr><tr><td>CasAuthenticationFilter</td><td>处理 CAS 单点登陆</td><td>NO</td></tr><tr><td>OAuth2LoginAuthenticationFilter</td><td>处理 OAuth2 认证</td><td>NO</td></tr><tr><td>Saml2WebSsoAuthenticationFilter</td><td>处理 SAML 认证</td><td>NO</td></tr><tr><td>UsernamePasswordAuthenticationFilter</td><td>处理表单登陆</td><td>YES</td></tr><tr><td>OpenIDAuthenticationFilter</td><td>处理 OpenID 认证</td><td>NO</td></tr><tr><td>DefaultLoginPageGeneratingFilter</td><td>配置默认登陆页面</td><td>YES</td></tr><tr><td>DefaultLogoutPageGeneratingFilter</td><td>配置默认注销页面</td><td>YES</td></tr><tr><td>ConcurrentSessionFilter</td><td>处理 Session 有效期</td><td>NO</td></tr><tr><td>DigestAuthenticationFilter</td><td>处理 HTTP 摘要认证</td><td>NO</td></tr><tr><td>BearerTokenAuthenticationFilter</td><td>处理 OAuth2 认证时的 Access Token</td><td>NO</td></tr><tr><td>BasicAuthenticationFilter</td><td>处理 HttpBasic 登陆</td><td>YES</td></tr><tr><td>RequestCacheAwareFilter</td><td>处理请求缓存</td><td>YES</td></tr><tr><td>SecurityContextHolderAwareRequestFilter</td><td>包装原始请求</td><td>YES</td></tr><tr><td>JaasApiIntegrationFilter</td><td>处理 JAAS 认证</td><td>NO</td></tr><tr><td>RememberMeAuthenticationFilter</td><td>处理 RememberMe 登陆</td><td>NO</td></tr><tr><td>AnonymousAuthenticationFilter</td><td>配置匿名认证</td><td>YES</td></tr><tr><td>OAuth2AuthoricationCodeGrantFilter</td><td>处理OAuth2 认证中的授权码</td><td>NO</td></tr><tr><td>SessionManagementFilter</td><td>处理 Session 并发问题</td><td>YES</td></tr><tr><td>ExceptionTranslationFilter</td><td>处理异常认证/授权中的情况</td><td>YES</td></tr><tr><td>FilterSecurityInterceptor</td><td>处理授权</td><td>YES</td></tr><tr><td>SwitchUserFilter</td><td>处理账户切换</td><td>NO</td></tr></tbody></table><p>开发者所见到的 Spring Security 提供的功能，都是通过这些过滤器来实现的，这些过滤器按照既定的优先级排列，最终形成一个过滤器链。开发者也可以自定义过滤器，并通过 @Order 注解去调整自定义过滤器在过滤器链中的位置。<br>需要注意的是，默认过滤器并不是直接放在 Web 项目的原生过滤器链中，而是通过一个 FilterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web 项目的原生过滤器链中，如下图所示：<br><img src="https://thumbimg.dealmoon.com/dealmoon/1cd/472/5c8/ea13b279a121606b869f254.jpg"></p><p>在 Spring Security 中，这样的过滤器链不仅仅只有一个，可能会有多个，当存在多个过滤器链时，多个过滤器链之间要指定优先级，当请求达到后，会从 FilterChainProxy 进行分发，先和哪个过滤器链匹配上，就用哪个过滤器链进行处理。当系统中存在多个不同的认证体系是，那么使用多个过滤器链就非常有效。<br><img src="https://thumbimg.dealmoon.com/dealmoon/1ba/012/2bc/a7cecf16be6783372c37615.jpg"></p><p>FilterChainProxy 作为一个顶层管理者，将统一管理 Security Filter。FilterChainProxy 本身将通过 Spring 框架提供的 DelegatingFilterProxy 整合到原生过滤器链中，如下图：<br><img src="https://thumbimg.dealmoon.com/dealmoon/a26/10a/e40/f582706a198ab0a5febfe7e.jpg"></p><h2><span id="过滤器链的初始化">过滤器链的初始化</span></h2><h3><span id="objectpostprocessor">ObjectPostProcessor</span></h3><p>ObjectPostProcessor 是 Spring Security 中使用频率最高的组件之一，它是一个后置处理器，也就是当一个对象创建成功后，如果还有一些额外的事情需要补充，那么就可以通过 ObjectPostProcessor 来进行处理。</p><h3><span id="xxxconfigurer">XxxConfigurer</span></h3><p>在 Spring Security 中，开发者可以灵活地配置项目中需要哪些 Spring Security 过滤器，一旦选定过滤器之后，每一个过滤器都会有一个对应的配置器，叫做XxxConfigurer，例如 CorsConfigurer、CsrfConfigurer 等。过滤器都是在 XxxConfigurer 中 new 出来的，然后上一节提到的 ObjectPostProcessor 的 postProcessor 方法中处理一遍，将这些过滤器注入到 Spring 容器中。</p><h3><span id="securityfilterchain">SecurityFilterChain</span></h3><p>SecurityFilterChain 就是 Spring Security 中的代表<strong>过滤器链</strong>的接口，它唯一的实现类为 DefaultSecurityFilterChain。</p><h3><span id="securitybuilder">SecurityBuilder</span></h3><p>Spring Security 中各种对象的都由某个对应的 SecurityBuilder 实现类创建。SecurityBuilder 有一个较为复杂的层级实现关系，以下简要说明一下各个子类所负责的逻辑：</p><ul><li>AbstractSecurityBuilder，对 SecurityBuilder 接口做了改进，确保 build 只执行一次；</li><li>AbstractConfiguredSecurityBuilder，新增了构建过程的状态的跟踪，新增了一个关键的 configurers 变量及对应的添加删除方法，用来维护所有的配置类；</li><li>ProviderManagerBuilder 接口，扩展了 SecurityBuilder 接口，其构建的对象为 AuthenticationManager 对象；</li><li>AuthenticationManagerBuilder，扩展了 AbstractConfiguredSecurityBuilder，并且实现了ProviderManagerBuilder 接口，构建过程主要涉及的内容包括 parentAuthenticationManager、Authentication 数据源（内存、jdbc等）、authenticationProvider（可多个） 等，构建生成对象是 AuthenticationManager 对象；</li><li>HttpSecurity，它 的主要作用是用来构建一条过滤器链，并反映到代码上，也就是构建一个 DefaultSecurityFilterChain 对象，<strong>一个 DefaultSecurityFilterChain 对象包含一个路径匹配器和多个 Spring 过滤器</strong>，HttpSecurity 中通过收集各种各样的 xxxConfigurer，将 Spring Security 过滤器对应的配置类收集起来，并保存到父类 AbstractConfiguredSecurityBuilder 的 configurers 变量中，在后续的构建过程中，再使用这些 xxxConfigurer 构建为具体的 Spring Security 过滤器，同时添加到 HttpSecurity 的 filter 对象中。每一个过滤器链都会有一个 AuthenticationManager 对象来进行认证操作，这里的 AuthenticationManager 对象在 <code>beforeConfigure()</code> 方法中完成构建。</li><li>WebSecurity，相比于 HttpSecurity，它是在一个更大的层面上去构建过滤器。一个 HttpSecurity 对象可以构建一个过滤器链，也就是一个 DefaultSecurityFilterChain 对象，而一个 项目中可以存在多个 HttpSecurity 对象，也就是可以构建多个 DefaultSecurityFilterChain 过滤器链。WebSecurity 负责将 HttpSecurity 所构建的 DefaultSecurityFilterChain（可能有多个），以及其它一些需要忽略的请求，再次重新构建为一个 <strong>FilterChainProxy</strong> 对象，同时添加上 HTTP 防火墙。</li></ul><h3><span id="filterchainproxy">FilterChainProxy</span></h3><p>FilterChainProxy  就是我们最终构建出来的代理过滤器链，通过 Spring 提供的 DelegatingFilterProxy 将 FilterChainProxy 集成到 WebFilter 中。所以，Spring Security 中的过滤器链的最终执行，就是在 FilterChainProxy 中。</p><h3><span id="securityconfigurer">SecurityConfigurer</span></h3><p>SecurityConfigurer 中有两个核心方法，一个是 init 方法，用来完成配置类的初始化操作，另一个就是 configure 方法，进行配置类的配置。SecurityConfigurer 的实现类比较多，其中包含：</p><ul><li>SecurityConfigurerAdapter，提供一个 SecurityBuilder，用来创建出具体的配置对象。内部还定义了一个 CompositePostProcessor 对象后置处理器。</li><li>UserDetailsAwareConfigurer，此类主要负责配置用户认证相关的组件，其中提供了获取 UserDetailsService 的抽象方法；</li><li>AbstractHttpConfigurer，主要为了给在 HttpSecurity 中使用的配置类添加一个方便的父类，提取共同的操作。</li><li>GlobalAuthenticationConfigurerAdapter，主要用于配置全局 AuthenticationManagerBuilder。</li><li>WebScurityConfigurer，用它来定义 WebSecurity。</li><li><strong>WebSecurityConfigurerAdapter，它是一个可以方便创建 WebScurityConfigurer 实例的基类，我们可以通过覆盖 WebSecurityConfigurerAdapter 中的方法来完成对 HttpSecurity 和 WebSecurity 的定制</strong>。</li></ul><h2><span id="整合到-spring-boot-体系中">整合到 Spring Boot 体系中</span></h2><p>在 Spring Boot 中使用 Spring Security，初始化就从 Spring Security 的自动化配置类中开始。</p><h3><span id="securityautoconfiguration">SecurityAutoConfiguration</span></h3><h4><span id="springbootwebsecurityconfiguration">SpringBootWebSecurityConfiguration</span></h4><h4><span id="securitydataconfiguration">SecurityDataConfiguration</span></h4><h4><span id="websecurityenablerconfiguration">WebSecurityEnablerConfiguration</span></h4><p>WebSecurityEnablerConfiguration 配置类中添加了 @EnableWebSecurity 注解，该注解是一个组合注解，它导入了三个配置类：</p><ul><li> WebSecurityConfiguration，用来配置 WebSecurity</li><li>SpringWebMvcImportSelector，判断当前环境是否存在 Spring MVC，如果存在，则引入相关配置</li><li>OAuth2ImportSelector，判断当前环境是否存在 OAuth2，如果存在，则引入相关配置。</li><li>@EnableGlobalAuthentication，导入配置类 AuthenticationConfiguration</li></ul><h1><span id="参考资料">参考资料</span></h1><p><a href="http://docs.spring.io/spring-security/site/docs/3.2.3.RELEASE/reference/htmlsingle/#preface">Spring Security Reference</a><br><a href="http://www.mkyong.com/tutorials/spring-security-tutorials/">Spring Security Tutorial</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;概述&quot;&gt;概述&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Spring Security，这是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。在 Spring Fr</summary>
      
    
    
    
    <category term="Spring Security" scheme="https://shucunbin.github.io/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="https://shucunbin.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 之 远程调用</title>
    <link href="https://shucunbin.github.io/2021/08/20/Spring%20Cloud%20%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <id>https://shucunbin.github.io/2021/08/20/Spring%20Cloud%20%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</id>
    <published>2021-08-20T07:12:10.000Z</published>
    <updated>2022-01-29T06:32:59.626Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="resttemplate">RestTemplate</span></h1><p>Spring web 提供了一个很好用的 REST 接口远程调用组件，叫做<strong>RestTemplate</strong>模板组件。该组件提供了多种便捷访问远程 REST 服务的方法，能够大大提高客户端的编写效率。在 SpringBoot 中可以通过以下逻辑获取 RestTemplate 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动配置 spring.factories -&gt; RestTemplateAutoConfiguration -&gt; RestTemplateBuilder</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplateBuilder restTemplateBuilder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/detail/v1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remoteCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 可以调用 restTemplateBuilder 提供的方法完成配置，最后调用 build 方法获取 RestTemplate 实例完成 rpc 调用</span></span><br><span class="line">    RestTemplate restTemplate = restTemplateBuilder.build();</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，RestTemplate 实现了对 HTTP 请求的封装处理，并且形成了一套模板化的调用方法。</p><h1><span id="feign">Feign</span></h1><p>Feign 是在 RestTemplate 基础上封装的，使用注解的方式来<strong>声明</strong>一组与服务提供者 REST 接口所对应的本地 Java 接口方法。Feign 将远程 REST 接口抽象成一个<strong>声明式</strong>的 Feign-Clien 客户端，并且负责完成 FeignClient 客户端和服务提供方的 REST 接口绑定。<br>在 Spring Cloud 中使用 Feign 通过以下几个步骤实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 引入依赖 - spring-cloud-starter-openfeign</span><br><span class="line">2. 在启动类上添加 @EnableFeignClient</span><br><span class="line">3. 编写声明式接口，然后添加 @FeignClient 注解</span><br></pre></td></tr></table></figure><p>使用自定义  <code>RequestInterceptor</code> 接口实现类解决 rpc 调用时的通用请求头透传问题。</p><h1><span id="feign-ribbon">Feign + Ribbon</span></h1><p>如果同一个服务存在多个实例，一般的负载均衡方案分为两种：</p><ul><li>服务端负载均衡，在客户端和服务提供者之间使用硬件（F5）或软件（Nginx）反向代理服务进行负载均衡；</li><li>客户端负载均衡，客户端自己维护一份从注册中心获取的服务提供者实例列表清单，根据自己配置的负载均衡算法在客户端进行请求的分发。Ribbon 就是一个客户端的负载均衡开源组件。</li></ul><p>Feign 组件自身不具备负载均衡能力，Feign 通过集成 Ribbon 组件实现客户端的负载均衡。在 Spring Cloud 只需引入依赖 <code>spring-cloud-starter-netflix-ribbon</code> 即可开启 Ribbon 的功能。Ribbon 支持的负载均衡策略：</p><ul><li>随机策略（RandomRule）</li><li>线性轮询策略（RoundRobinRule）</li><li>响应时间权重策略（WeightedResponseTimeRule），响应时间越长，权重越小</li><li>最少连接策略（BestAvailableRule），选取当前连接数最少的 Provider，内部有一个 LoadBalancerStat 成员变量，存储所有 Provider 的运行状况和连接数。</li><li>重试策略（RetryRule），每次选取后会对选取的 Provider 进行判断，如果为 null 或者 not alive，就会在一定时限内进行循环重试。</li><li>可用过滤策略（AvailabilityFilteringRule），扩展了线性轮询策略，首先通过线性轮询策略选取一个 Provider，然后再判断 Provider 是否超时可用，当前连接数是否超过限制，如果都符合要求，就成功返回。</li><li>区域过滤策略（ZoneAvoidanceRule），该类扩展了线性轮询策略，除了过滤超时和连接数过多的 Provider 之外，还会过滤掉不符合要求的 Zone 区域内的所有节点。Spring Cloud 默认使用此策略。</li></ul><p>Spring Cloud 中配置负载均衡策略的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件方式</span><br><span class="line">ribbon.NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule - 全局配置</span><br><span class="line">provider-name.ribbon.NFLoadBalancerRuleClassName = com.netflix.loadbalancer.RandomRule - 针对某个服务提供者配置</span><br><span class="line"></span><br><span class="line"># Java 代码配置方式</span><br><span class="line">// 全局</span><br><span class="line">@Configuration</span><br><span class="line">public class RibbonConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public IRule defaultLBStrategy() &#123;</span><br><span class="line">        return new BestAvailableRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 针对某个服务提供者</span><br><span class="line">@Configuration</span><br><span class="line">@RibbonClient(name = &quot;provider-name&quot;, configuration=com.netflix.loadbalancer.RandomRule.class)</span><br><span class="line">public class RibbonConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public IRule defaultLBStrategy() &#123;</span><br><span class="line">        return new RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ribbon 的其它配置，针对全局或某个服务提供者的逻辑跟配置负载均衡策略一致，其中重试相关配置起效须添加spring-retry 依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 请求链接的超时时间</span><br><span class="line">ribbon.ConnectTimeOut</span><br><span class="line"># 请求处理的超时时间</span><br><span class="line">ribbon.ReadTimeout:</span><br><span class="line"># 对所有操作都重试（默认只对 GET 请求重试）</span><br><span class="line">ribbon.OkToRetyrOnAllOperations: true</span><br><span class="line"># 切换实例的重试次数（不包含第一个实例）</span><br><span class="line">ribbon.MaxAutoRetyiesNextServer: 1</span><br><span class="line"># 对当前实例的重试次数（不包含第一次）</span><br><span class="line">ribbon.MaxAutoRetries: 1</span><br><span class="line"># 对特定的 HTTP 响应码进行重试</span><br><span class="line">ribbon.retryableStatusCodes: 400,401</span><br><span class="line"># 从注册中心刷新 Provider 的时间间隔</span><br><span class="line">ribbon.ServerListRefreshInterval: 2000</span><br></pre></td></tr></table></figure><h1><span id="feign-hystrix">Feign + Hystrix</span></h1><p>Hystrix 是一个服务降级、限流、熔断组件，主要用于在远程 Provider 服务异常时，对<strong>对消费端的 RPC 进行保护</strong>，避免引起雪崩效应。<br>在 Spring Cloud 中通过以下几个步骤开启 Hystrix 功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 引入依赖：spring-cloud-starter-netflix-hystrix</span><br><span class="line">2. 在应用属性配置文件中开启 Feign 对 Hystrix 的支持：feign.hystrix.enabled=true</span><br><span class="line">3. 在服务启动类上添加 `@EnableCircuitBreaker` 或 ` EnableHystrix` 注解</span><br></pre></td></tr></table></figure><p>Fallback 与 FallbackFactory 的区别：Fallback 的方式会屏蔽触发熔断的异常，而 FallbackFactory 可以保留的异常信息。</p><p>Hystrix 熔断器的工作机制：统计最近 RPC 调用发生错误的次数，然后根据统计值中的成功、失败、超时比例等信息来决定是否允许后面的 RPC 调用继续或者快速失败回退。熔断器有 3 中状态，分别为 关闭（closed）、开启（open）、半开启（half-open）。<br>Hystrix 的配置参数主要分为两类：熔断器相关参数和滑动窗口相关参数。<br>熔断器相关参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 是否启动熔断器，默认为 true</span><br><span class="line">hystrix.command.default.circuitBreaker.enabled</span><br><span class="line"></span><br><span class="line"># 设置熔断器触发熔断的最小请求次数，默认值为 20</span><br><span class="line">hystrix.command.default.circuitBreaker.requestVolumeThreshold</span><br><span class="line"></span><br><span class="line"># 配置错误率阈值，在时间窗口时间内，当错误率超过此值时，熔断器进入 open 状态，所有请求都会发生失败回退，默认值为 50</span><br><span class="line">hystrix.command.default.circuitBreaker.errorThresholdPercentage</span><br><span class="line"></span><br><span class="line"># 配置睡眠窗口的大小，即熔断器打开之后，多久之后允许一次请求尝试执行，默认值为 5000 ms</span><br><span class="line">hystrix.command.default.circuitBreaker.sleepWindownMillseconds</span><br><span class="line"></span><br><span class="line"># 强制打开熔断器，默认值为 false</span><br><span class="line">hystrix.command.default.circuitBreaker.forceOpen</span><br></pre></td></tr></table></figure><p>滑动窗口相关配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 滑动窗口的持续时间，默认值为 10000 毫秒</span><br><span class="line">hystrix.command.default.metrics.rollingStats.timeInMilliseconds</span><br><span class="line"></span><br><span class="line"># 滑动窗口被划分的时间桶数量</span><br><span class="line">hystrix.command.default.metrics.rollingStats.numBuckets</span><br></pre></td></tr></table></figure><h1><span id="feign-ribbon-hystrix-完整执行流程">feign + ribbon + hystrix 完整执行流程</span></h1><ol><li>生成 feign 注解标识的接口的动态代理实例，并完成装配；</li><li>HystrixInvocationHandler 中的 invoke 方法对从 dispatch 获取的 SynchronousMethodHandler 进行封装，返回 HystrixCommand 命令实例。注：HystrixInvocationHandler 实例内部有一个 map 类型 dispatch 成员，它保存这远程方法反射实例和方法处理器（MethodHandler）；</li><li>执行 HystrixCommand 实例的 run 方法，内部调用 MethodHandler invoke 方法，如果调用异常，这返回回退结果；</li><li>执行 MethodHandler 方法处理器的 invoke 方法，MethodHandler 实例内部有一个 client 成员，默认的 client 通过 JDK 自带的 HttpURLConnection 类完成远程调用；</li><li>集成 ribbon 时，client 类型为 LoadBalancerFeignClient 负载均衡客户端时，使用 Ribbon 获取最佳 provider 实例，然后委托内部的 delegate 完成实际的请求；</li><li>通过 ribbon 内部的 delegate 的 client 客户端成员完成远程URL请求执行和获取远程结果；</li></ol><h1><span id="超时时间的配置">超时时间的配置</span></h1><p>如果同时启用 feign、ribbon、hystrix 的功能，client 整体的包含逻辑为 hystrix -&gt; retry -&gt; ribbon/feign，以设计意图来说，Feign Client 的配置关注在每次 Http Request 上，Retry 关注的是 Feign Client 出问题以后的 Retry 逻辑，而 Hystrix 关心的是整个调用何时能成功，出错了如何 fallback，所有调用的并发控制，是否要熔断终止调用等问题。<br>源码入口：<code>FeignClientFactoryBean</code> -&gt; <code>DefaultTargeter</code> -&gt;  <code>ReflectiveFeign</code>  -&gt; <code>HystrixInvocationHandler</code> -&gt; <code>HystrixCommand</code> -&gt; <code>LoadBalancerFeignClient</code> -&gt;<code>OkHttpClient</code>。<br>Feign 超时相关的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#连接超时时间</span><br><span class="line">feign.client.config.default.connectTimeout=5000</span><br><span class="line">#读取超时时间</span><br><span class="line">feign.client.config.default.readTimeout=5000    </span><br></pre></td></tr></table></figure><p>Hystrix 超时相关的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=12000</span><br></pre></td></tr></table></figure><p>Ribbon 超时相关的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#说明：同一台实例的最大自动重试次数，默认为1次，不包括首次</span><br><span class="line">ribbon.MaxAutoRetries=1</span><br><span class="line">#说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例</span><br><span class="line">ribbon.MaxAutoRetriesNextServer: 1</span><br><span class="line">#说明：是否所有的操作都重试，默认为true</span><br><span class="line">ribbon.OkToRetryOnAllOperations: true</span><br><span class="line">#说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒</span><br><span class="line">ribbon.ServerListRefreshInterval: 2000</span><br><span class="line">#说明：使用Apache HttpClient连接超时时间，单位为毫秒</span><br><span class="line">ribbon.ConnectTimeout: 3000</span><br><span class="line">#说明：使用Apache HttpClient读取的超时时间，单位为毫秒</span><br><span class="line">ribbon.ReadTimeout: 3000</span><br></pre></td></tr></table></figure><p>如果同时配置了 Feign 与 Ribbon 的超时时间，Feign 与配置会覆盖 Ribbon 的配置，详情见 <code>RibbonLoadBalancingHttpClient.execute()</code>。<br>Hystrix 超时时间与 Feign/Ribbon 超时时间的关系：</p><blockquote><p>Hystrix的超时时间&gt;=Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)</p></blockquote><p>Ribbon 重试次数：</p><blockquote><p>Ribbon重试次数(包含首次)= 1 + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer  +  (ribbon.MaxAutoRetries * ribbon.MaxAutoRetriesNextServer)</p></blockquote><h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.cnblogs.com/crazymakercircle/p/11664812.html">Feign Ribbon Hystrix 三者关系 | 史上最全, 深度解析</a><br><a href="https://xli1224.github.io/2017/09/14/feign-anaylsis/">Feign 源码解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;resttemplate&quot;&gt;RestTemplate&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Spring web 提供了一个很好用的 REST 接口远程调用组件，叫做&lt;strong&gt;RestTemplate&lt;/strong&gt;模板组件。该组件提供了多种便捷访问远程</summary>
      
    
    
    
    <category term="Spring Cloud" scheme="https://shucunbin.github.io/categories/Spring-Cloud/"/>
    
    
    <category term="分布式" scheme="https://shucunbin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty 前置知识点之事件循环机制</title>
    <link href="https://shucunbin.github.io/2020/11/12/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://shucunbin.github.io/2020/11/12/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-12T02:23:10.000Z</published>
    <updated>2022-01-29T06:13:13.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/04%20%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6%E5%B1%82%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%20EventLoop%20%E6%98%AF%20Netty%20%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%9F.md">原文链接</a></p><h1><span id="基本概念">基本概念</span></h1><p>事件循环（EventLoop）这个概念其实并不是 Netty 独有的，它是一种事件等待和处理的程序模型，可以解决多线程资源消耗高的问题。例如 Node.js 就采用了 EventLoop 的运行机制，不仅占用资源低，而且能够支撑了大规模的流量访问。<br>下图展示了 EventLoop 通用的运行模式。每当事件发生时，应用程序都会将产生的事件放入事件队列当中，然后 EventLoop 会轮询从队列中取出事件执行或者将事件分给相应的事件监听者执行。事件执行的方式通常分为立即执行、延后执行、定期执行几种。<br><img src="https://thumbimg.dealmoon.com/dealmoon/3a2/688/621/7927f790413d80d513ade32.png"></p><h1><span id="netty-如何实现-eventloop">Netty 如何实现 EventLoop</span></h1><p>在 Netty 中 EventLoop 可以理解为 Reactor 线程模型的事件处理引擎，每个 EventLoop 线程都维护一个 Selector 选择器和任务队列 taskQueue。它主要负责处理 IO 事件、普通任务和定时任务。<br>Netty 中推荐使用 NioEventLoop 作为实现类，其实现核心逻辑在 NioEventLoop 的 run() 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">// 1. 轮询 IO 事件</span></span><br><span class="line">        slelect(wokenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 2. 处理 IO 事件</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line">        <span class="comment">// 3. 处理其它非 IO 事件</span></span><br><span class="line">        runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述源码的结构比较清晰，NioEventLoop 每次循环的处理流程都包含事件轮询 select、事件处理 processSelectedKeys、任务处理 runAllTasks 几个步骤，是典型的 Reactor 线程模型的运行机制。而且 Netty 提供类一个 ioRatio，可以调整 IO 事件处理和任务处理的时间比例。</p><h2><span id="io-事件处理">IO 事件处理</span></h2><p><img src="https://thumbimg.dealmoon.com/dealmoon/5c5/d8e/63b/a8481886b17aaf1d4e767f4.png"><br>EventLoop 事件处理机制最核心的是采用<strong>无锁串形化的设计思路</strong>：</p><ul><li>BossEventLoopGroup 和 WorkerEventLoopGroup 包含一个或者多个 NioEventLoop。BossEventLoopGroup 负责监听客户端的 Accept 事件，当事件触发时，将事件注册至 WorkerEventLoopGroup 中的一个 NioEventLoop 上。每新建一个 Channel， 只选择一个 NioEventLoop 与其绑定。所以说 Channel 生命周期的所有事件处理都是线程独立的，不同的 NioEventLoop 线程之间不会发生任何交集。</li><li>NioEventLoop 完成数据读取后，会调用绑定的 ChannelPipeline 进行事件传播，ChannelPipeline 也是线程安全的，数据会被传递到 ChannelPipeline 的第一个 ChannelHandler 中。数据处理完成后，将加工完成的数据再传递给下一个 ChannelHandler，整个过程是串行化执行，不会发生线程上下文切换的问题。</li></ul><p>NioEventLoop 无锁串形化的设计不仅使系统吞吐量达到最大化，而且降低了用户开发业务逻辑的难度，不需要花太多精力关心线程安全问题。虽然单线程执行避免了线程切换，但是它的缺陷就是不能执行时间过长的 I/O 操作，一旦某个 I/O 事件发生阻塞，那么后续的所有 I/O 事件都无法执行，甚至造成事件积压。<strong>在使用 Netty 进行程序开发时，我们一定要对 ChannelHandler 的实现逻辑有充分的风险意识</strong>。<br>Netty 解决  JDK Epoll 空轮询的方式：</p><ol><li>每次执行 Select 操作之前记录当前时间 currentTimeNanos</li><li>time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos，如果事件轮询的持续时间大于等于 timeoutMillis，那么说明是正常的，否则表明阻塞时间并未达到预期，可能触发了空轮询的 Bug。（如何探测）</li><li>Netty 引入了计数变量 selectCnt。在正常情况下，selectCnt 会重置，否则会对 selectCnt 自增计数。当 selectCnt 达到 SELECTOR_AUTO_REBUILD_THRESHOLD（默认512） 阈值时，会触发重建 Selector 对象。（重建策略）</li></ol><h2><span id="其它任务处理">其它任务处理</span></h2><p>NioEventLoop 不仅负责处理 I/O 事件，还要兼顾执行任务队列中的任务。任务队列遵循 FIFO 规则，可以保证任务执行的公平性。NioEventLoop 处理的任务类型基本可以分为三类。</p><ol><li>普通任务：通过 NioEventLoop 的 execute() 方法向任务队列 taskQueue 中添加任务。例如 Netty 在写数据时会封装 WriteAndFlushTask 提交给 taskQueue。taskQueue 的实现类是多生产者单消费者队列 MpscChunkedArrayQueue，在多线程并发添加任务时，可以保证线程安全。</li><li>定时任务：通过调用 NioEventLoop 的 schedule() 方法向定时任务队列 scheduledTaskQueue 添加一个定时任务，用于周期性执行该任务。例如，心跳消息发送等。定时任务队列 scheduledTaskQueue 采用优先队列 PriorityQueue 实现。</li><li>尾部队列：tailTasks 相比于普通任务队列优先级较低，在每次执行完 taskQueue 中任务后会去获取尾部队列中任务执行。尾部任务并不常用，主要用于做一些收尾工作，例如统计事件循环的执行时间、监控信息上报等。</li></ol><p>NioEventLoop 处理任务的逻辑源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取即将可执行的定时任务，放入普通任务队列中</span></span><br><span class="line">        fetchFromScheduledTaskQueue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从普通任务队列中取出任务</span></span><br><span class="line">        Runnable task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterRunningAllTasks();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 计算任务处理超时时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">        <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 4. 执行任务（直接执行任务的 run 方法）</span></span><br><span class="line">            safeExecute(task);</span><br><span class="line"></span><br><span class="line">            runTasks ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 每执行 64 个任务，检查一下是否超时</span></span><br><span class="line">            <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            task = pollTask();</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 执行 tailTasks 队列中的任务，tailTasks 相比于普通任务队列优先级较低，主要用于做一些收尾工作，例如统计事件循环执行时间、监控信息上报等。</span></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="关于-eventloop-一些好的实践">关于 EventLoop 一些好的实践</span></h2><p>实际开发中，一些好的 EventLoop 实践：</p><ol><li>网络连接建立过程中三次握手、安全认证的过程会消耗不少时间，建议采用 Reactor 主从线程模型，MainReactor 线程处理客户端请求接入，SubReactor 线程：数据读取、I/O 事件的分发与执行。</li><li>由于 Reactor 线程模式适合处理耗时短的任务场景，对于耗时较长的 ChannelHandler 可以考虑维护一个<strong>业务线程池</strong>，将编解码后的数据封装成 Task 进行异步处理，避免 ChannelHandler 阻塞而造成 EventLoop 不可用。</li><li>如果业务逻辑执行时间较短，建议直接在 ChannelHandler 中执行。例如编解码操作，这样可以避免过度设计而造成架构的复杂性。</li><li>不宜设计过多的 ChannelHandler。对于系统性能和可维护性都会存在问题，在设计业务架构的时候，需要明确业务分层和 Netty 分层之间的界限。不要一味地将业务逻辑都添加到 ChannelHandler 中。</li></ol><h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.jianshu.com/p/3ec120ca46b2">JDK Epoll 空轮询 bug</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%</summary>
      
    
    
    
    <category term="Netty" scheme="https://shucunbin.github.io/categories/Netty/"/>
    
    
    <category term="事件循环" scheme="https://shucunbin.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Netty 前置知识点之 Reactor 反应器模式</title>
    <link href="https://shucunbin.github.io/2020/11/11/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%20Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shucunbin.github.io/2020/11/11/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%20Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-11T09:44:15.000Z</published>
    <updated>2022-01-29T02:47:58.857Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="概要">概要</span></h1><p>Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握  Nginx、Redis、Netty 这些中间件技术。总之，反应器模式是高性能网络编程的必知必会的模式。</p><h1><span id="什么是-reactor-反应器模式">什么是 Reactor 反应器模式</span></h1><p>Doug Lea 在 文章 <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a> 中对反应器模式的定义：反应器模式由 Reactor 反应器线程、Handlers 处理器两大角色组成：</p><ul><li>Reactor 反应器线程的职责 - 负责响应 IO 事件，并且分发到 Handlers 处理器；</li><li>Handlers 处理器的职责：非阻塞的执行业务处理逻辑。</li></ul><h1><span id="reactor-反应器模式的演进">Reactor 反应器模式的演进</span></h1><h2><span id="connection-per-thread-模式">Connection Per Thread 模式</span></h2><p>Connection Per Thread，顾名思义，即对于每一个新的网络连接都分配一个线程，每个线程独立处理自己负责的输入和输出。当然，服务器的监听线程也是独立的，任何 socket 连接的输入和输出处理，不会阻塞后面新来连接的监听和建立。</p><p>Connection Per Thread 模式的优点是解决了前面的新连接被严重阻塞的问题，在一定程度上，极大地提高了服务器的吞吐量。<br>Connection Per Thread 模式的缺点是：对应于大量的连接，需要耗费大量的线程资源，在操作系统中，线程的创建、销毁、切换都需要不菲的代价。因此，在高并发的应用场景下，这种模式的缺陷是致命的。</p><h2><span id="单线程-recator-反应器模式">单线程 Recator 反应器模式</span></h2><p>为了解决 Connection Per Thread 模式的缺陷，我们使用 Reactor 反应器模式对线程的数量进行控制，做到<strong>一个线程处理大量的连接</strong>。<br>前面已经提到，在反应器模式中，有 Reactor 反应器和 Handler 处理器两个重要的组件：</p><ul><li>Reactor 反应器：负责查询 IO 事件，当检测到一个 IO 事件，将其发送给相应的 Handler 处理器去处理。<strong>这里的 IO 事件，就是 NIO 中选择器监控的通道 IO 事件</strong>。</li><li>Handler 处理器：与 IO 事件（或者选择键）绑定，负责 IO 事件的处理。<strong>完成真正的连接建立、通道数据的读取、处理业务逻辑、负责将结果写出到通道等</strong>。</li></ul><p>单线程 Reactor 反应器模式 指的是 Reactor 反应器和 Handlers 处理器处于一个线程中执行，它是最简单的反应器模型。基于 Java NIO 实现单线程  Reactor 反应器模式的核心 API 是类 SelectionKey 的以下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">attachment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其中，Handler 处理器实例将作为附件添加到 SelectionKey 实例中，当 IO 事件发生时，选择键被 select() 方法选到后，可以直接将事件处理器实例从附件取出，然后调用方法完成相应的处理。</p><p>单线程 Reactor反应器模式的缺点：<br>单线程 Reactor 反应器模式，是基于 Java 的 NIO 实现的，相对于传统的多线程 OIO，反应器模式不再需要启动很多线程，取而代之，Reactor 反应器和 Handler 处理器执行在同一条线程上，这样，带来了一个问题，<strong>当其中某个 Handler 阻塞时，会导致其它所有的 Handler 都得不到执行。在这种场景下，如果被阻塞的 Handler 不仅仅负责输入和输出处理的业务，还包括负责连接监听的 AcceptHandler 处理器，这个是非常严重的问题。一旦 AcceptHandler 处理器阻塞，会导致整个服务不能接收新的连接，使得服务器变得不可用。</strong>正因如此，在高性能服务器应用场景中，单线程反应器模式实际使用的很少。</p><h2><span id="多线程-recator-反应器模式">多线程 Recator 反应器模式</span></h2><p>针对单线程  Reactor 反应器的缺点，使用多线程，对基础反应器模式进行改造升级，即将负责输入输出的 Handler 处理器执行，放入独立的线程池中。这样，业务处理线程与负责监听和 IO 事件查询的反应器线程相互隔离，避免服务器的连接监听受到阻塞。<br>理论上，这种模式依然有一个地方是单点的，那就是处理客户端连接的线程。因为大多数服务端应用或多或少在连接时都会处理一些业务，如鉴权之类的，当连接的客户端越来越多时这一个线程依然会存在性能问题。</p><h2><span id="主从多线程的-reactor-反应器模式">主从多线程的 Reactor 反应器模式</span></h2><p>这种模式是在多线程 Reactor 反应器模式的基础上，将 Reactor 反应器拆分为多个子反应器线程，每一个 SubReactor 子线程负责一个选择器。这样可以充分使用系统处理能力，提高反应器管理连接的数量，提升选择大量通道的能力。</p><h1><span id="小结">小结</span></h1><h2><span id="反应器模式和生产者消费者模式对比">反应器模式和生产者消费者模式对比</span></h2><p>相似之处：在一定程度上，反应器模式有点类似生产者消费者模式。在生产者消费者模式中，一个或多个生产者将事件加入到一个队里中，一个或多个消费者主动地从这个队列中提取事件来处理。<br>不同之处：反应器模式是<strong>基于查询</strong>的，没有专门的队列去缓冲存储 IO 事件，查询到 IO 事件之后，反应器会根据不同 IO 选择键（事件）将其分发给对应的 Handler 处理。</p><h2><span id="反应器模式优缺点">反应器模式优缺点</span></h2><p>反应器模式优点：</p><ul><li>响应快，虽然同一反应器线程本身是同步的，但不会被单个连接的同步 IO 所阻塞；</li><li>编程相对简单，最大程度避免了复杂的多线程同步，也避免了多线程的切换的开销；</li><li>可扩展，可以方便地通过增加反应器线程的个数来充分利用 CPU 资源；</li></ul><p>反应器模式缺点：</p><ul><li>反应器模式增加了一定的复杂性，因而有一定的门槛，并且不易于调试；</li><li>反应器模式需要操作系统底层的 IO 多路复用的支持，如 Linux 中的 epoll，如果操作系统的底层不支持 IO 多路复用，反应器模式不会有那么高效；</li><li>同一个 Handler 业务线程中，如果出现一个长时间的数据读写，会影响这个反应器中其它通道的 IO 处理。因而，对于这种类型的处理，还需要进一步对反应器模式进行改进。</li></ul><h1><span id="参考资料">参考资料</span></h1><p>《Netty、Redis、Zookeeper 高并发实战》<br><a href="https://bbs.huaweicloud.com/blogs/266248?utm_source=zhihu&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">高性能网络框架：Reactor 和 Proactor</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;概要&quot;&gt;概要&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握 </summary>
      
    
    
    
    <category term="Netty" scheme="https://shucunbin.github.io/categories/Netty/"/>
    
    
    <category term="线程模型" scheme="https://shucunbin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 之接口默认方法及静态方法</title>
    <link href="https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</id>
    <published>2019-07-11T09:44:15.000Z</published>
    <updated>2022-01-29T02:18:14.568Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概要">概要</span></h2><p>Java 8 新增了很多语言特性，其中涉及接口的有<strong>默认方法</strong>、<strong>静态方法</strong>，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员也同样适用。</p><p>静态方法旨在替代常见的伴生类，例如 Collection 类的伴生类 Collections 类、Path 类的半生类 Paths。</p><p>默认方法一来解决接口演化问题，二来替代抽象骨干类，例如 Collection 接口的抽象骨干类 AbstractCollection 类。</p><h2><span id="默认方法">默认方法</span></h2><p>默认方法，简而言之，就是在一个接口里使用 <code>default </code> 关键字定义的一个方法，所有该接口的实现类都可以直接使用而无须自己实现此方法。</p><p>默认方法存在的主要目的是为了方便扩展已有接口，如果没有默认方法，给一个已经发布的接口添加方法时，所有实现改接口的地方都得做修改，如果该接口的使用范围很广，那相应的影响也非常之大，例如 JDK 里定义的各种接口。因此，Java 8 中加入了此语言特性使得类库设计人员可以很方便的扩展已有的接口。</p><h3><span id="重写规则">重写规则</span></h3><p>实现包含默认方法的接口，有以下三种可能的方式：</p><ul><li>实现类不重写默认方法，直接使用接口中的默认方法；</li><li>子接口或抽象类将默认方法声明为普通的抽象方法；</li><li>实现类中重写默认方法，与重写普通的接口方法一样。</li></ul><p>如果使用代码片段描述这三种方式则如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        message(<span class="string">&quot;Parent: Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 不对默认方法做任何重写，直接使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 子接口或抽象类重新声明默认方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> BaseParent implements Parent &#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实现类重写默认方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message(<span class="string">&quot;Child: Hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个复杂的继承体系里，存在多个子类或子接口都重写了默认方法，到底哪个其作用呢？可以使用一句话简单概括其规则：<strong>类中重写的方法胜出。</strong>这样的设计主要是由增加默认方法的目的决定的，增加默认方法主要是为了在接口上向后兼容。让类中重写方法的优先级高于默认方法能简化很多继承问题</p><h3><span id="多重继承问题">多重继承问题</span></h3><p>接口允许多重继承，因此有可能碰到两个接口包含签名相同的默认方法的情况，如果一个类同时实现这两个接口，它到底该继承哪个接口的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, Foo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, Bar!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>,<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译失败，编译器提示：class FooBar inherits unrelated defaults for hello() from types Foo and Bar.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决此问题，我们需要显示的实现或声明 <code>hello()</code> 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">Foo</span>,<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现逻辑</span></span><br><span class="line">        <span class="keyword">return</span> Foo.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFooBar</span> <span class="keyword">implements</span> <span class="title">Foor</span>, <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="静态方法">静态方法</span></h2><p>我们在编程过程中，有时会将创建一些工具类，这些类里包含了大量的静态方法，例如 Objects 类、Collections 类等，这些工具方法，在语义上它们不具体属于某个类。但如果一个方法有充分的语义原因和某个概念相关，那么就应该将该方法和相关的类或接口放在一起，而不是放到另一个工具类中。</p><p>例如，Java 8 中引入的 <code>Stream</code> 接口，如果想创建一个由简单值组成的<code>Stream</code>，自然希望<code>Stream</code>接口就有一个这样的方法，而不是使用额外的工具类。这在以前很难达成，直到 Java 8 中为接口加入了静态方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料</span></h2><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">The Java™ Tutorials - Default Methods</a></p><p><a href="http://www.ituring.com.cn/book/1448">Java 8函数式编程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;概要&quot;&gt;概要&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Java 8 新增了很多语言特性，其中涉及接口的有&lt;strong&gt;默认方法&lt;/strong&gt;、&lt;strong&gt;静态方法&lt;/strong&gt;，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员</summary>
      
    
    
    
    <category term="Java 基础" scheme="https://shucunbin.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java 8" scheme="https://shucunbin.github.io/tags/Java-8/"/>
    
  </entry>
  
</feed>
