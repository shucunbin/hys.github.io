{"meta":{"title":"shucunbin's blog","subtitle":"","description":"","author":"shucunbin","url":"https://shucunbin.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-01-29T02:24:13.473Z","updated":"2022-01-29T02:24:13.473Z","comments":false,"path":"books/index.html","permalink":"https://shucunbin.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-29T02:23:34.730Z","updated":"2022-01-29T02:23:34.730Z","comments":false,"path":"categories/index.html","permalink":"https://shucunbin.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-29T02:23:44.993Z","updated":"2022-01-29T02:23:44.993Z","comments":false,"path":"tags/index.html","permalink":"https://shucunbin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Security 学习札记（一）：基本概念","slug":"Spring Security 学习札记（一）：基本概念","date":"2021-11-12T09:30:15.000Z","updated":"2022-01-29T06:50:40.072Z","comments":true,"path":"2021/11/12/Spring Security 学习札记（一）：基本概念/","link":"","permalink":"https://shucunbin.github.io/2021/11/12/Spring%20Security%20%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"概述Spring Security，这是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。在 Spring Framework 基础上，Spring Security 充分利用了依赖注入（DI，Dependency Injection）和面向切面技术。 实现机制在 Sping Security 中，认证、授权等功能都是基于过滤器来完成的。以下是常见的过滤器，这里的是否默认加载指的是引入 Spring Security 依赖之后，开发者不做任何配置时，会自动加载的过滤器： 过滤器 过滤器作用 是否默认加载 ChannelProcessingFilter 过滤请求协议，如 HTTPS 和 HTTP NO WebAsyncManagerIntegrationFilter 将 WebAsyncManager 与 Spring Security 上下文进行集成 YES SecurityContextPersistenceFilter 在处理请求之前，将安全信息加载到 SecurityContextHolder中以方便后续使用。请求结束后，再擦除 SecurityContextHolder 中的信息 YES HeaderWriterFilter 头信息加入响应中 YES CorsFilter 处理跨域问题 NO CsrfFilter 处理 CSRF 攻击 YES LogoutFilter 处理注销登陆 YES OAuth2AuthorizationRequestRedirectFilter 处理 OAuth2 认证重定向 NO Saml2WebSsoAuthenticationRequestFilter 处理 SAML 认证 NO X509AuthenticationFilter 处理 X509 认证 NO AbstractPreAuthenticationFilter 处理预认证问题 NO CasAuthenticationFilter 处理 CAS 单点登陆 NO OAuth2LoginAuthenticationFilter 处理 OAuth2 认证 NO Saml2WebSsoAuthenticationFilter 处理 SAML 认证 NO UsernamePasswordAuthenticationFilter 处理表单登陆 YES OpenIDAuthenticationFilter 处理 OpenID 认证 NO DefaultLoginPageGeneratingFilter 配置默认登陆页面 YES DefaultLogoutPageGeneratingFilter 配置默认注销页面 YES ConcurrentSessionFilter 处理 Session 有效期 NO DigestAuthenticationFilter 处理 HTTP 摘要认证 NO BearerTokenAuthenticationFilter 处理 OAuth2 认证时的 Access Token NO BasicAuthenticationFilter 处理 HttpBasic 登陆 YES RequestCacheAwareFilter 处理请求缓存 YES SecurityContextHolderAwareRequestFilter 包装原始请求 YES JaasApiIntegrationFilter 处理 JAAS 认证 NO RememberMeAuthenticationFilter 处理 RememberMe 登陆 NO AnonymousAuthenticationFilter 配置匿名认证 YES OAuth2AuthoricationCodeGrantFilter 处理OAuth2 认证中的授权码 NO SessionManagementFilter 处理 Session 并发问题 YES ExceptionTranslationFilter 处理异常认证/授权中的情况 YES FilterSecurityInterceptor 处理授权 YES SwitchUserFilter 处理账户切换 NO 开发者所见到的 Spring Security 提供的功能，都是通过这些过滤器来实现的，这些过滤器按照既定的优先级排列，最终形成一个过滤器链。开发者也可以自定义过滤器，并通过 @Order 注解去调整自定义过滤器在过滤器链中的位置。需要注意的是，默认过滤器并不是直接放在 Web 项目的原生过滤器链中，而是通过一个 FilterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web 项目的原生过滤器链中，如下图所示： 在 Spring Security 中，这样的过滤器链不仅仅只有一个，可能会有多个，当存在多个过滤器链时，多个过滤器链之间要指定优先级，当请求达到后，会从 FilterChainProxy 进行分发，先和哪个过滤器链匹配上，就用哪个过滤器链进行处理。当系统中存在多个不同的认证体系是，那么使用多个过滤器链就非常有效。 FilterChainProxy 作为一个顶层管理者，将统一管理 Security Filter。FilterChainProxy 本身将通过 Spring 框架提供的 DelegatingFilterProxy 整合到原生过滤器链中，如下图： 过滤器链的初始化ObjectPostProcessorObjectPostProcessor 是 Spring Security 中使用频率最高的组件之一，它是一个后置处理器，也就是当一个对象创建成功后，如果还有一些额外的事情需要补充，那么就可以通过 ObjectPostProcessor 来进行处理。 XxxConfigurer在 Spring Security 中，开发者可以灵活地配置项目中需要哪些 Spring Security 过滤器，一旦选定过滤器之后，每一个过滤器都会有一个对应的配置器，叫做XxxConfigurer，例如 CorsConfigurer、CsrfConfigurer 等。过滤器都是在 XxxConfigurer 中 new 出来的，然后上一节提到的 ObjectPostProcessor 的 postProcessor 方法中处理一遍，将这些过滤器注入到 Spring 容器中。 SecurityFilterChainSecurityFilterChain 就是 Spring Security 中的代表过滤器链的接口，它唯一的实现类为 DefaultSecurityFilterChain。 SecurityBuilderSpring Security 中各种对象的都由某个对应的 SecurityBuilder 实现类创建。SecurityBuilder 有一个较为复杂的层级实现关系，以下简要说明一下各个子类所负责的逻辑： AbstractSecurityBuilder，对 SecurityBuilder 接口做了改进，确保 build 只执行一次； AbstractConfiguredSecurityBuilder，新增了构建过程的状态的跟踪，新增了一个关键的 configurers 变量及对应的添加删除方法，用来维护所有的配置类； ProviderManagerBuilder 接口，扩展了 SecurityBuilder 接口，其构建的对象为 AuthenticationManager 对象； AuthenticationManagerBuilder，扩展了 AbstractConfiguredSecurityBuilder，并且实现了ProviderManagerBuilder 接口，构建过程主要涉及的内容包括 parentAuthenticationManager、Authentication 数据源（内存、jdbc等）、authenticationProvider（可多个） 等，构建生成对象是 AuthenticationManager 对象； HttpSecurity，它 的主要作用是用来构建一条过滤器链，并反映到代码上，也就是构建一个 DefaultSecurityFilterChain 对象，一个 DefaultSecurityFilterChain 对象包含一个路径匹配器和多个 Spring 过滤器，HttpSecurity 中通过收集各种各样的 xxxConfigurer，将 Spring Security 过滤器对应的配置类收集起来，并保存到父类 AbstractConfiguredSecurityBuilder 的 configurers 变量中，在后续的构建过程中，再使用这些 xxxConfigurer 构建为具体的 Spring Security 过滤器，同时添加到 HttpSecurity 的 filter 对象中。每一个过滤器链都会有一个 AuthenticationManager 对象来进行认证操作，这里的 AuthenticationManager 对象在 beforeConfigure() 方法中完成构建。 WebSecurity，相比于 HttpSecurity，它是在一个更大的层面上去构建过滤器。一个 HttpSecurity 对象可以构建一个过滤器链，也就是一个 DefaultSecurityFilterChain 对象，而一个 项目中可以存在多个 HttpSecurity 对象，也就是可以构建多个 DefaultSecurityFilterChain 过滤器链。WebSecurity 负责将 HttpSecurity 所构建的 DefaultSecurityFilterChain（可能有多个），以及其它一些需要忽略的请求，再次重新构建为一个 FilterChainProxy 对象，同时添加上 HTTP 防火墙。 FilterChainProxyFilterChainProxy 就是我们最终构建出来的代理过滤器链，通过 Spring 提供的 DelegatingFilterProxy 将 FilterChainProxy 集成到 WebFilter 中。所以，Spring Security 中的过滤器链的最终执行，就是在 FilterChainProxy 中。 SecurityConfigurerSecurityConfigurer 中有两个核心方法，一个是 init 方法，用来完成配置类的初始化操作，另一个就是 configure 方法，进行配置类的配置。SecurityConfigurer 的实现类比较多，其中包含： SecurityConfigurerAdapter，提供一个 SecurityBuilder，用来创建出具体的配置对象。内部还定义了一个 CompositePostProcessor 对象后置处理器。 UserDetailsAwareConfigurer，此类主要负责配置用户认证相关的组件，其中提供了获取 UserDetailsService 的抽象方法； AbstractHttpConfigurer，主要为了给在 HttpSecurity 中使用的配置类添加一个方便的父类，提取共同的操作。 GlobalAuthenticationConfigurerAdapter，主要用于配置全局 AuthenticationManagerBuilder。 WebScurityConfigurer，用它来定义 WebSecurity。 WebSecurityConfigurerAdapter，它是一个可以方便创建 WebScurityConfigurer 实例的基类，我们可以通过覆盖 WebSecurityConfigurerAdapter 中的方法来完成对 HttpSecurity 和 WebSecurity 的定制。 整合到 Spring Boot 体系中在 Spring Boot 中使用 Spring Security，初始化就从 Spring Security 的自动化配置类中开始。 SecurityAutoConfigurationSpringBootWebSecurityConfigurationSecurityDataConfigurationWebSecurityEnablerConfigurationWebSecurityEnablerConfiguration 配置类中添加了 @EnableWebSecurity 注解，该注解是一个组合注解，它导入了三个配置类： WebSecurityConfiguration，用来配置 WebSecurity SpringWebMvcImportSelector，判断当前环境是否存在 Spring MVC，如果存在，则引入相关配置 OAuth2ImportSelector，判断当前环境是否存在 OAuth2，如果存在，则引入相关配置。 @EnableGlobalAuthentication，导入配置类 AuthenticationConfiguration 参考资料Spring Security ReferenceSpring Security Tutorial","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://shucunbin.github.io/categories/Spring-Security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://shucunbin.github.io/tags/Spring-Security/"}]},{"title":"Spring Cloud 之 远程调用","slug":"Spring Cloud 之远程调用","date":"2021-08-20T07:12:10.000Z","updated":"2022-01-29T06:32:59.626Z","comments":true,"path":"2021/08/20/Spring Cloud 之远程调用/","link":"","permalink":"https://shucunbin.github.io/2021/08/20/Spring%20Cloud%20%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/","excerpt":"","text":"RestTemplateSpring web 提供了一个很好用的 REST 接口远程调用组件，叫做RestTemplate模板组件。该组件提供了多种便捷访问远程 REST 服务的方法，能够大大提高客户端的编写效率。在 SpringBoot 中可以通过以下逻辑获取 RestTemplate 实例： 1234567891011// 自动配置 spring.factories -&gt; RestTemplateAutoConfiguration -&gt; RestTemplateBuilder@Resourceprivate RestTemplateBuilder restTemplateBuilder;@GetMapping(&quot;/user/detail/v1&quot;)public void remoteCall() &#123; //... // 可以调用 restTemplateBuilder 提供的方法完成配置，最后调用 build 方法获取 RestTemplate 实例完成 rpc 调用 RestTemplate restTemplate = restTemplateBuilder.build(); //... &#125; 本质上，RestTemplate 实现了对 HTTP 请求的封装处理，并且形成了一套模板化的调用方法。 FeignFeign 是在 RestTemplate 基础上封装的，使用注解的方式来声明一组与服务提供者 REST 接口所对应的本地 Java 接口方法。Feign 将远程 REST 接口抽象成一个声明式的 Feign-Clien 客户端，并且负责完成 FeignClient 客户端和服务提供方的 REST 接口绑定。在 Spring Cloud 中使用 Feign 通过以下几个步骤实现： 1231. 引入依赖 - spring-cloud-starter-openfeign2. 在启动类上添加 @EnableFeignClient3. 编写声明式接口，然后添加 @FeignClient 注解 使用自定义 RequestInterceptor 接口实现类解决 rpc 调用时的通用请求头透传问题。 Feign + Ribbon如果同一个服务存在多个实例，一般的负载均衡方案分为两种： 服务端负载均衡，在客户端和服务提供者之间使用硬件（F5）或软件（Nginx）反向代理服务进行负载均衡； 客户端负载均衡，客户端自己维护一份从注册中心获取的服务提供者实例列表清单，根据自己配置的负载均衡算法在客户端进行请求的分发。Ribbon 就是一个客户端的负载均衡开源组件。 Feign 组件自身不具备负载均衡能力，Feign 通过集成 Ribbon 组件实现客户端的负载均衡。在 Spring Cloud 只需引入依赖 spring-cloud-starter-netflix-ribbon 即可开启 Ribbon 的功能。Ribbon 支持的负载均衡策略： 随机策略（RandomRule） 线性轮询策略（RoundRobinRule） 响应时间权重策略（WeightedResponseTimeRule），响应时间越长，权重越小 最少连接策略（BestAvailableRule），选取当前连接数最少的 Provider，内部有一个 LoadBalancerStat 成员变量，存储所有 Provider 的运行状况和连接数。 重试策略（RetryRule），每次选取后会对选取的 Provider 进行判断，如果为 null 或者 not alive，就会在一定时限内进行循环重试。 可用过滤策略（AvailabilityFilteringRule），扩展了线性轮询策略，首先通过线性轮询策略选取一个 Provider，然后再判断 Provider 是否超时可用，当前连接数是否超过限制，如果都符合要求，就成功返回。 区域过滤策略（ZoneAvoidanceRule），该类扩展了线性轮询策略，除了过滤超时和连接数过多的 Provider 之外，还会过滤掉不符合要求的 Zone 区域内的所有节点。Spring Cloud 默认使用此策略。 Spring Cloud 中配置负载均衡策略的方式： 1234567891011121314151617181920212223# 配置文件方式ribbon.NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule - 全局配置provider-name.ribbon.NFLoadBalancerRuleClassName = com.netflix.loadbalancer.RandomRule - 针对某个服务提供者配置# Java 代码配置方式// 全局@Configurationpublic class RibbonConfiguration &#123; @Bean public IRule defaultLBStrategy() &#123; return new BestAvailableRule(); &#125;&#125;// 针对某个服务提供者@Configuration@RibbonClient(name = &quot;provider-name&quot;, configuration=com.netflix.loadbalancer.RandomRule.class)public class RibbonConfiguration &#123; @Bean public IRule defaultLBStrategy() &#123; return new RandomRule(); &#125;&#125; Ribbon 的其它配置，针对全局或某个服务提供者的逻辑跟配置负载均衡策略一致，其中重试相关配置起效须添加spring-retry 依赖： 1234567891011121314# 请求链接的超时时间ribbon.ConnectTimeOut# 请求处理的超时时间ribbon.ReadTimeout:# 对所有操作都重试（默认只对 GET 请求重试）ribbon.OkToRetyrOnAllOperations: true# 切换实例的重试次数（不包含第一个实例）ribbon.MaxAutoRetyiesNextServer: 1# 对当前实例的重试次数（不包含第一次）ribbon.MaxAutoRetries: 1# 对特定的 HTTP 响应码进行重试ribbon.retryableStatusCodes: 400,401# 从注册中心刷新 Provider 的时间间隔ribbon.ServerListRefreshInterval: 2000 Feign + HystrixHystrix 是一个服务降级、限流、熔断组件，主要用于在远程 Provider 服务异常时，对对消费端的 RPC 进行保护，避免引起雪崩效应。在 Spring Cloud 中通过以下几个步骤开启 Hystrix 功能： 1231. 引入依赖：spring-cloud-starter-netflix-hystrix2. 在应用属性配置文件中开启 Feign 对 Hystrix 的支持：feign.hystrix.enabled=true3. 在服务启动类上添加 `@EnableCircuitBreaker` 或 ` EnableHystrix` 注解 Fallback 与 FallbackFactory 的区别：Fallback 的方式会屏蔽触发熔断的异常，而 FallbackFactory 可以保留的异常信息。 Hystrix 熔断器的工作机制：统计最近 RPC 调用发生错误的次数，然后根据统计值中的成功、失败、超时比例等信息来决定是否允许后面的 RPC 调用继续或者快速失败回退。熔断器有 3 中状态，分别为 关闭（closed）、开启（open）、半开启（half-open）。Hystrix 的配置参数主要分为两类：熔断器相关参数和滑动窗口相关参数。熔断器相关参数： 1234567891011121314# 是否启动熔断器，默认为 truehystrix.command.default.circuitBreaker.enabled# 设置熔断器触发熔断的最小请求次数，默认值为 20hystrix.command.default.circuitBreaker.requestVolumeThreshold# 配置错误率阈值，在时间窗口时间内，当错误率超过此值时，熔断器进入 open 状态，所有请求都会发生失败回退，默认值为 50hystrix.command.default.circuitBreaker.errorThresholdPercentage# 配置睡眠窗口的大小，即熔断器打开之后，多久之后允许一次请求尝试执行，默认值为 5000 mshystrix.command.default.circuitBreaker.sleepWindownMillseconds# 强制打开熔断器，默认值为 falsehystrix.command.default.circuitBreaker.forceOpen 滑动窗口相关配置： 12345# 滑动窗口的持续时间，默认值为 10000 毫秒hystrix.command.default.metrics.rollingStats.timeInMilliseconds# 滑动窗口被划分的时间桶数量hystrix.command.default.metrics.rollingStats.numBuckets feign + ribbon + hystrix 完整执行流程 生成 feign 注解标识的接口的动态代理实例，并完成装配； HystrixInvocationHandler 中的 invoke 方法对从 dispatch 获取的 SynchronousMethodHandler 进行封装，返回 HystrixCommand 命令实例。注：HystrixInvocationHandler 实例内部有一个 map 类型 dispatch 成员，它保存这远程方法反射实例和方法处理器（MethodHandler）； 执行 HystrixCommand 实例的 run 方法，内部调用 MethodHandler invoke 方法，如果调用异常，这返回回退结果； 执行 MethodHandler 方法处理器的 invoke 方法，MethodHandler 实例内部有一个 client 成员，默认的 client 通过 JDK 自带的 HttpURLConnection 类完成远程调用； 集成 ribbon 时，client 类型为 LoadBalancerFeignClient 负载均衡客户端时，使用 Ribbon 获取最佳 provider 实例，然后委托内部的 delegate 完成实际的请求； 通过 ribbon 内部的 delegate 的 client 客户端成员完成远程URL请求执行和获取远程结果； 超时时间的配置如果同时启用 feign、ribbon、hystrix 的功能，client 整体的包含逻辑为 hystrix -&gt; retry -&gt; ribbon/feign，以设计意图来说，Feign Client 的配置关注在每次 Http Request 上，Retry 关注的是 Feign Client 出问题以后的 Retry 逻辑，而 Hystrix 关心的是整个调用何时能成功，出错了如何 fallback，所有调用的并发控制，是否要熔断终止调用等问题。源码入口：FeignClientFactoryBean -&gt; DefaultTargeter -&gt; ReflectiveFeign -&gt; HystrixInvocationHandler -&gt; HystrixCommand -&gt; LoadBalancerFeignClient -&gt;OkHttpClient。Feign 超时相关的配置： 1234#连接超时时间feign.client.config.default.connectTimeout=5000#读取超时时间feign.client.config.default.readTimeout=5000 Hystrix 超时相关的配置： 1hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=12000 Ribbon 超时相关的配置： 123456789101112#说明：同一台实例的最大自动重试次数，默认为1次，不包括首次ribbon.MaxAutoRetries=1#说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例ribbon.MaxAutoRetriesNextServer: 1#说明：是否所有的操作都重试，默认为trueribbon.OkToRetryOnAllOperations: true#说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒ribbon.ServerListRefreshInterval: 2000#说明：使用Apache HttpClient连接超时时间，单位为毫秒ribbon.ConnectTimeout: 3000#说明：使用Apache HttpClient读取的超时时间，单位为毫秒ribbon.ReadTimeout: 3000 如果同时配置了 Feign 与 Ribbon 的超时时间，Feign 与配置会覆盖 Ribbon 的配置，详情见 RibbonLoadBalancingHttpClient.execute()。Hystrix 超时时间与 Feign/Ribbon 超时时间的关系： Hystrix的超时时间&gt;=Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout) Ribbon 重试次数： Ribbon重试次数(包含首次)= 1 + ribbon.MaxAutoRetries + ribbon.MaxAutoRetriesNextServer + (ribbon.MaxAutoRetries * ribbon.MaxAutoRetriesNextServer) 参考资料Feign Ribbon Hystrix 三者关系 | 史上最全, 深度解析Feign 源码解析","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://shucunbin.github.io/categories/Spring-Cloud/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://shucunbin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Netty 前置知识点之事件循环机制","slug":"Netty 前置知识点之事件循环机制","date":"2020-11-12T02:23:10.000Z","updated":"2022-01-29T06:13:13.036Z","comments":true,"path":"2020/11/12/Netty 前置知识点之事件循环机制/","link":"","permalink":"https://shucunbin.github.io/2020/11/12/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"原文链接 基本概念事件循环（EventLoop）这个概念其实并不是 Netty 独有的，它是一种事件等待和处理的程序模型，可以解决多线程资源消耗高的问题。例如 Node.js 就采用了 EventLoop 的运行机制，不仅占用资源低，而且能够支撑了大规模的流量访问。下图展示了 EventLoop 通用的运行模式。每当事件发生时，应用程序都会将产生的事件放入事件队列当中，然后 EventLoop 会轮询从队列中取出事件执行或者将事件分给相应的事件监听者执行。事件执行的方式通常分为立即执行、延后执行、定期执行几种。 Netty 如何实现 EventLoop在 Netty 中 EventLoop 可以理解为 Reactor 线程模型的事件处理引擎，每个 EventLoop 线程都维护一个 Selector 选择器和任务队列 taskQueue。它主要负责处理 IO 事件、普通任务和定时任务。Netty 中推荐使用 NioEventLoop 作为实现类，其实现核心逻辑在 NioEventLoop 的 run() 方法中。 12345678910protected void run() &#123; for(;;) &#123; // 1. 轮询 IO 事件 slelect(wokenUp.getAndSet(false)); // 2. 处理 IO 事件 processSelectedKeys(); // 3. 处理其它非 IO 事件 runAllTasks(); &#125;&#125; 上述源码的结构比较清晰，NioEventLoop 每次循环的处理流程都包含事件轮询 select、事件处理 processSelectedKeys、任务处理 runAllTasks 几个步骤，是典型的 Reactor 线程模型的运行机制。而且 Netty 提供类一个 ioRatio，可以调整 IO 事件处理和任务处理的时间比例。 IO 事件处理EventLoop 事件处理机制最核心的是采用无锁串形化的设计思路： BossEventLoopGroup 和 WorkerEventLoopGroup 包含一个或者多个 NioEventLoop。BossEventLoopGroup 负责监听客户端的 Accept 事件，当事件触发时，将事件注册至 WorkerEventLoopGroup 中的一个 NioEventLoop 上。每新建一个 Channel， 只选择一个 NioEventLoop 与其绑定。所以说 Channel 生命周期的所有事件处理都是线程独立的，不同的 NioEventLoop 线程之间不会发生任何交集。 NioEventLoop 完成数据读取后，会调用绑定的 ChannelPipeline 进行事件传播，ChannelPipeline 也是线程安全的，数据会被传递到 ChannelPipeline 的第一个 ChannelHandler 中。数据处理完成后，将加工完成的数据再传递给下一个 ChannelHandler，整个过程是串行化执行，不会发生线程上下文切换的问题。 NioEventLoop 无锁串形化的设计不仅使系统吞吐量达到最大化，而且降低了用户开发业务逻辑的难度，不需要花太多精力关心线程安全问题。虽然单线程执行避免了线程切换，但是它的缺陷就是不能执行时间过长的 I/O 操作，一旦某个 I/O 事件发生阻塞，那么后续的所有 I/O 事件都无法执行，甚至造成事件积压。在使用 Netty 进行程序开发时，我们一定要对 ChannelHandler 的实现逻辑有充分的风险意识。Netty 解决 JDK Epoll 空轮询的方式： 每次执行 Select 操作之前记录当前时间 currentTimeNanos time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos，如果事件轮询的持续时间大于等于 timeoutMillis，那么说明是正常的，否则表明阻塞时间并未达到预期，可能触发了空轮询的 Bug。（如何探测） Netty 引入了计数变量 selectCnt。在正常情况下，selectCnt 会重置，否则会对 selectCnt 自增计数。当 selectCnt 达到 SELECTOR_AUTO_REBUILD_THRESHOLD（默认512） 阈值时，会触发重建 Selector 对象。（重建策略） 其它任务处理NioEventLoop 不仅负责处理 I/O 事件，还要兼顾执行任务队列中的任务。任务队列遵循 FIFO 规则，可以保证任务执行的公平性。NioEventLoop 处理的任务类型基本可以分为三类。 普通任务：通过 NioEventLoop 的 execute() 方法向任务队列 taskQueue 中添加任务。例如 Netty 在写数据时会封装 WriteAndFlushTask 提交给 taskQueue。taskQueue 的实现类是多生产者单消费者队列 MpscChunkedArrayQueue，在多线程并发添加任务时，可以保证线程安全。 定时任务：通过调用 NioEventLoop 的 schedule() 方法向定时任务队列 scheduledTaskQueue 添加一个定时任务，用于周期性执行该任务。例如，心跳消息发送等。定时任务队列 scheduledTaskQueue 采用优先队列 PriorityQueue 实现。 尾部队列：tailTasks 相比于普通任务队列优先级较低，在每次执行完 taskQueue 中任务后会去获取尾部队列中任务执行。尾部任务并不常用，主要用于做一些收尾工作，例如统计事件循环的执行时间、监控信息上报等。 NioEventLoop 处理任务的逻辑源码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041protected boolean runAllTasks(long timeoutNanos) &#123; // 1. 获取即将可执行的定时任务，放入普通任务队列中 fetchFromScheduledTaskQueue(); // 2. 从普通任务队列中取出任务 Runnable task = pollTask(); if (task == null) &#123; afterRunningAllTasks(); return false; &#125; // 3. 计算任务处理超时时间 final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos; long runTasks = 0; long lastExecutionTime; for (;;) &#123; // 4. 执行任务（直接执行任务的 run 方法） safeExecute(task); runTasks ++; // 5. 每执行 64 个任务，检查一下是否超时 if ((runTasks &amp; 0x3F) == 0) &#123; lastExecutionTime = ScheduledFutureTask.nanoTime(); if (lastExecutionTime &gt;= deadline) &#123; break; &#125; &#125; task = pollTask(); if (task == null) &#123; lastExecutionTime = ScheduledFutureTask.nanoTime(); break; &#125; &#125; // 6. 执行 tailTasks 队列中的任务，tailTasks 相比于普通任务队列优先级较低，主要用于做一些收尾工作，例如统计事件循环执行时间、监控信息上报等。 afterRunningAllTasks(); this.lastExecutionTime = lastExecutionTime; return true; &#125; 关于 EventLoop 一些好的实践实际开发中，一些好的 EventLoop 实践： 网络连接建立过程中三次握手、安全认证的过程会消耗不少时间，建议采用 Reactor 主从线程模型，MainReactor 线程处理客户端请求接入，SubReactor 线程：数据读取、I/O 事件的分发与执行。 由于 Reactor 线程模式适合处理耗时短的任务场景，对于耗时较长的 ChannelHandler 可以考虑维护一个业务线程池，将编解码后的数据封装成 Task 进行异步处理，避免 ChannelHandler 阻塞而造成 EventLoop 不可用。 如果业务逻辑执行时间较短，建议直接在 ChannelHandler 中执行。例如编解码操作，这样可以避免过度设计而造成架构的复杂性。 不宜设计过多的 ChannelHandler。对于系统性能和可维护性都会存在问题，在设计业务架构的时候，需要明确业务分层和 Netty 分层之间的界限。不要一味地将业务逻辑都添加到 ChannelHandler 中。 参考资料JDK Epoll 空轮询 bug","categories":[{"name":"Netty","slug":"Netty","permalink":"https://shucunbin.github.io/categories/Netty/"}],"tags":[{"name":"事件循环","slug":"事件循环","permalink":"https://shucunbin.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"}]},{"title":"Netty 前置知识点之 Reactor 反应器模式","slug":"Netty 前置知识点之 Reactor 反应器模式","date":"2020-11-11T09:44:15.000Z","updated":"2022-01-29T02:47:58.857Z","comments":true,"path":"2020/11/11/Netty 前置知识点之 Reactor 反应器模式/","link":"","permalink":"https://shucunbin.github.io/2020/11/11/Netty%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%20Reactor%20%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"概要Reactor 反应器模式是高性能网络编程在设计和架构层面的基础模式。很多服务器软件或者中间件都是基于反应器模式实现的，如 Ngnix Web 服务器、Redis、Netty等，只有掌握了它，才能真正理解掌握 Nginx、Redis、Netty 这些中间件技术。总之，反应器模式是高性能网络编程的必知必会的模式。 什么是 Reactor 反应器模式Doug Lea 在 文章 Scalable IO in Java 中对反应器模式的定义：反应器模式由 Reactor 反应器线程、Handlers 处理器两大角色组成： Reactor 反应器线程的职责 - 负责响应 IO 事件，并且分发到 Handlers 处理器； Handlers 处理器的职责：非阻塞的执行业务处理逻辑。 Reactor 反应器模式的演进Connection Per Thread 模式Connection Per Thread，顾名思义，即对于每一个新的网络连接都分配一个线程，每个线程独立处理自己负责的输入和输出。当然，服务器的监听线程也是独立的，任何 socket 连接的输入和输出处理，不会阻塞后面新来连接的监听和建立。 Connection Per Thread 模式的优点是解决了前面的新连接被严重阻塞的问题，在一定程度上，极大地提高了服务器的吞吐量。Connection Per Thread 模式的缺点是：对应于大量的连接，需要耗费大量的线程资源，在操作系统中，线程的创建、销毁、切换都需要不菲的代价。因此，在高并发的应用场景下，这种模式的缺陷是致命的。 单线程 Recator 反应器模式为了解决 Connection Per Thread 模式的缺陷，我们使用 Reactor 反应器模式对线程的数量进行控制，做到一个线程处理大量的连接。前面已经提到，在反应器模式中，有 Reactor 反应器和 Handler 处理器两个重要的组件： Reactor 反应器：负责查询 IO 事件，当检测到一个 IO 事件，将其发送给相应的 Handler 处理器去处理。这里的 IO 事件，就是 NIO 中选择器监控的通道 IO 事件。 Handler 处理器：与 IO 事件（或者选择键）绑定，负责 IO 事件的处理。完成真正的连接建立、通道数据的读取、处理业务逻辑、负责将结果写出到通道等。 单线程 Reactor 反应器模式 指的是 Reactor 反应器和 Handlers 处理器处于一个线程中执行，它是最简单的反应器模型。基于 Java NIO 实现单线程 Reactor 反应器模式的核心 API 是类 SelectionKey 的以下两个方法： 12void attach(Object o);Object attachment(); 其中，Handler 处理器实例将作为附件添加到 SelectionKey 实例中，当 IO 事件发生时，选择键被 select() 方法选到后，可以直接将事件处理器实例从附件取出，然后调用方法完成相应的处理。 单线程 Reactor反应器模式的缺点：单线程 Reactor 反应器模式，是基于 Java 的 NIO 实现的，相对于传统的多线程 OIO，反应器模式不再需要启动很多线程，取而代之，Reactor 反应器和 Handler 处理器执行在同一条线程上，这样，带来了一个问题，当其中某个 Handler 阻塞时，会导致其它所有的 Handler 都得不到执行。在这种场景下，如果被阻塞的 Handler 不仅仅负责输入和输出处理的业务，还包括负责连接监听的 AcceptHandler 处理器，这个是非常严重的问题。一旦 AcceptHandler 处理器阻塞，会导致整个服务不能接收新的连接，使得服务器变得不可用。正因如此，在高性能服务器应用场景中，单线程反应器模式实际使用的很少。 多线程 Recator 反应器模式针对单线程 Reactor 反应器的缺点，使用多线程，对基础反应器模式进行改造升级，即将负责输入输出的 Handler 处理器执行，放入独立的线程池中。这样，业务处理线程与负责监听和 IO 事件查询的反应器线程相互隔离，避免服务器的连接监听受到阻塞。理论上，这种模式依然有一个地方是单点的，那就是处理客户端连接的线程。因为大多数服务端应用或多或少在连接时都会处理一些业务，如鉴权之类的，当连接的客户端越来越多时这一个线程依然会存在性能问题。 主从多线程的 Reactor 反应器模式这种模式是在多线程 Reactor 反应器模式的基础上，将 Reactor 反应器拆分为多个子反应器线程，每一个 SubReactor 子线程负责一个选择器。这样可以充分使用系统处理能力，提高反应器管理连接的数量，提升选择大量通道的能力。 小结反应器模式和生产者消费者模式对比相似之处：在一定程度上，反应器模式有点类似生产者消费者模式。在生产者消费者模式中，一个或多个生产者将事件加入到一个队里中，一个或多个消费者主动地从这个队列中提取事件来处理。不同之处：反应器模式是基于查询的，没有专门的队列去缓冲存储 IO 事件，查询到 IO 事件之后，反应器会根据不同 IO 选择键（事件）将其分发给对应的 Handler 处理。 反应器模式优缺点反应器模式优点： 响应快，虽然同一反应器线程本身是同步的，但不会被单个连接的同步 IO 所阻塞； 编程相对简单，最大程度避免了复杂的多线程同步，也避免了多线程的切换的开销； 可扩展，可以方便地通过增加反应器线程的个数来充分利用 CPU 资源； 反应器模式缺点： 反应器模式增加了一定的复杂性，因而有一定的门槛，并且不易于调试； 反应器模式需要操作系统底层的 IO 多路复用的支持，如 Linux 中的 epoll，如果操作系统的底层不支持 IO 多路复用，反应器模式不会有那么高效； 同一个 Handler 业务线程中，如果出现一个长时间的数据读写，会影响这个反应器中其它通道的 IO 处理。因而，对于这种类型的处理，还需要进一步对反应器模式进行改进。 参考资料《Netty、Redis、Zookeeper 高并发实战》高性能网络框架：Reactor 和 Proactor","categories":[{"name":"Netty","slug":"Netty","permalink":"https://shucunbin.github.io/categories/Netty/"}],"tags":[{"name":"线程模型","slug":"线程模型","permalink":"https://shucunbin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"}]},{"title":"Java 8 之接口默认方法及静态方法","slug":"Java 8 之接口默认方法及静态方法","date":"2019-07-11T09:44:15.000Z","updated":"2022-01-29T02:18:14.568Z","comments":true,"path":"2019/07/11/Java 8 之接口默认方法及静态方法/","link":"","permalink":"https://shucunbin.github.io/2019/07/11/Java%208%20%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%8F%8A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","excerpt":"","text":"概要Java 8 新增了很多语言特性，其中涉及接口的有默认方法、静态方法，这些语言特性旨在帮助编写类库的开发人员，但对我们日常写应用程序的开发人员也同样适用。 静态方法旨在替代常见的伴生类，例如 Collection 类的伴生类 Collections 类、Path 类的半生类 Paths。 默认方法一来解决接口演化问题，二来替代抽象骨干类，例如 Collection 接口的抽象骨干类 AbstractCollection 类。 默认方法默认方法，简而言之，就是在一个接口里使用 default 关键字定义的一个方法，所有该接口的实现类都可以直接使用而无须自己实现此方法。 默认方法存在的主要目的是为了方便扩展已有接口，如果没有默认方法，给一个已经发布的接口添加方法时，所有实现改接口的地方都得做修改，如果该接口的使用范围很广，那相应的影响也非常之大，例如 JDK 里定义的各种接口。因此，Java 8 中加入了此语言特性使得类库设计人员可以很方便的扩展已有的接口。 重写规则实现包含默认方法的接口，有以下三种可能的方式： 实现类不重写默认方法，直接使用接口中的默认方法； 子接口或抽象类将默认方法声明为普通的抽象方法； 实现类中重写默认方法，与重写普通的接口方法一样。 如果使用代码片段描述这三种方式则如下所示： 123456789101112131415161718192021222324252627282930public interface Parent &#123; void message(String body); default void welcome()&#123; message(&quot;Parent: Hi!&quot;); &#125;&#125;// 1. 不对默认方法做任何重写，直接使用public class Child implements Parent &#123; public void message(String body) &#123; System.out.println(body); &#125;&#125;// 2. 子接口或抽象类重新声明默认方法public abstract BaseParent implements Parent &#123; abstract void welcome();&#125;// 3. 实现类重写默认方法public class Child implements Parent &#123; public void message(String body) &#123; System.out.println(body); &#125; public void welcome() &#123; message(&quot;Child: Hi!&quot;); &#125;&#125; 如果一个复杂的继承体系里，存在多个子类或子接口都重写了默认方法，到底哪个其作用呢？可以使用一句话简单概括其规则：类中重写的方法胜出。这样的设计主要是由增加默认方法的目的决定的，增加默认方法主要是为了在接口上向后兼容。让类中重写方法的优先级高于默认方法能简化很多继承问题 多重继承问题接口允许多重继承，因此有可能碰到两个接口包含签名相同的默认方法的情况，如果一个类同时实现这两个接口，它到底该继承哪个接口的呢？ 123456789101112131415public interface Foo &#123; default String hello() &#123; return &quot;hello, Foo!&quot; &#125;&#125;public interface Bar &#123; default String hello() &#123; return &quot;hello, Bar!&quot;; &#125;&#125;public class FooBar implements Foo,Bar &#123; // 编译失败，编译器提示：class FooBar inherits unrelated defaults for hello() from types Foo and Bar.&#125; 解决此问题，我们需要显示的实现或声明 hello() 方法，如下所示： 12345678910public class FooBar implements Foo,Bar &#123; public String hello() &#123; // 实现逻辑 return Foo.super.hello(); &#125;&#125;public abstract class BaseFooBar implements Foor, Bar &#123; public abstract String hello();&#125; 静态方法我们在编程过程中，有时会将创建一些工具类，这些类里包含了大量的静态方法，例如 Objects 类、Collections 类等，这些工具方法，在语义上它们不具体属于某个类。但如果一个方法有充分的语义原因和某个概念相关，那么就应该将该方法和相关的类或接口放在一起，而不是放到另一个工具类中。 例如，Java 8 中引入的 Stream 接口，如果想创建一个由简单值组成的Stream，自然希望Stream接口就有一个这样的方法，而不是使用额外的工具类。这在以前很难达成，直到 Java 8 中为接口加入了静态方法，如下所示： 123public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values);&#125; 参考资料The Java™ Tutorials - Default Methods Java 8函数式编程","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"https://shucunbin.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java 8","slug":"Java-8","permalink":"https://shucunbin.github.io/tags/Java-8/"}]}],"categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://shucunbin.github.io/categories/Spring-Security/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://shucunbin.github.io/categories/Spring-Cloud/"},{"name":"Netty","slug":"Netty","permalink":"https://shucunbin.github.io/categories/Netty/"},{"name":"Java 基础","slug":"Java-基础","permalink":"https://shucunbin.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://shucunbin.github.io/tags/Spring-Security/"},{"name":"分布式","slug":"分布式","permalink":"https://shucunbin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"事件循环","slug":"事件循环","permalink":"https://shucunbin.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"name":"线程模型","slug":"线程模型","permalink":"https://shucunbin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"name":"Java 8","slug":"Java-8","permalink":"https://shucunbin.github.io/tags/Java-8/"}]}